\chapter{Fachlichesumfeld}\label{chp:fachlichesumfeld}

\section{RS-232 (Radio Sector 232)}

Die Quellen dieses Kapitel sind aus dem Wikipedia Artikel \cite{RS232}, aus den Büchern "`C Programmers Guide to Serial Communications"' \cite{CProgrammersGuide} und "`V 24 / RS-232 Kommunikation"' \cite{V24/RS232}.

\paragraph{}
Der RS-232 ist ein Standard der in den 60er Jahren von dem US-amerikanischen Standardisierungskomitee Electronic Industries Association(EIA) bearbeitet?? (entwickelt) und definiert wurde. Bei diesem Standard handelt es sich um eine serielle Schnittstelle, die für die serielle Kommunikation zwischen Rechnern und Modems für eine Punkt-zu-Punkt Verbindung (über Telefonleitungen) entwickelt wurde.


%#######################################################################################
\subsection{Definition}
\paragraph{}

Der RS-232 Standard definiert eine Verbindung zwischen einer Datenendeinrichtung (DEE, zum Beispiel das Terminal) und einer Datenübertragungseinrichtung (DÜE, zum Beispiel einem Modem) und dessen Parameter. Unter den einzelnen Parametern sind folgende Eigenschaften zu verstehen:
\begin{enumerate}
\item Spannungspegel
\item Übertragungsprotokoll (Handshake)
\item Stecker
\item Timing
\end{enumerate}

Die Übertragung ist Bit-seriell, das heißt, die Bits werden hintereinander in einer Datenleitung verschickt. Eine bestimmte Menge an Bits entspricht einem Zeichen. Ein Zeichen besteht aus einem Startbit, aus vier bis acht Datenbits (Nutzdaten), aus ein oder zwei Stopbits und der Parität. Die Parität ist in dem Standard nicht definiert, aber wird benutzt um Fehler zu erkennen und zu beheben. Im Allgemeinen ist die Parität nebensächlich, da sie aber in diesem Fall der Arbeit relevant ist wird sie im späteren Verlauf des Kapitels näher erklärt.


\subsection{Übertragung}
\paragraph{}
Das Startbit meldet dem Empfänger das die Übertragung anfängt. Die Start- und Stopbits haben inversen Pegeln. Ist eine Leitung im Ruhezustand oder hat die Stopbits erhalten, wird durch die Ankunft einer inversen Signalflanke der Empfänger aufmerksam gemacht, dass Nutzdaten ankommen werden. Bei der Ankunft eines Startbits tastet der Empfänger die Nutzdaten mit seiner Bitrate (Bits pro Sekunde) ab. Die Nutzdaten sind die Bitdarstellung von einem ASCII Zeichnen. Die Länge der Daten sind einstellbar, dabei kann die Übertragung von vier bis acht Bits pro Zeichen eingestellt werden. Im Anschluss kommt mindestens ein Stopbit, es können auch 1,5 Bits oder zwei Bits eingestellt werden. 1,5 Bits sind sehr ungewöhnlich, aber damit ist gemeint, dass die Mindestdauer der Pause zwischen zwei ankommenden Zeichen 1,5 Bitzeichen entspricht. 

\paragraph{}
Im Folgenden wird die Übertragung von einem Zeichen näher erläutert:
Wird ein Zeichen 'z' übertragen, mit einem Startbit, acht Datenbits und zwei Stopbits, ist die Gesamtlänge der Übertragung elf Bits lang. 'z' entspricht laut ASCII Kodierung den Wert 122 dezimal und "`7A"' hexadezimal(0x7A). Die Bitdarstellung für 0x7 lautet "`0111"' und für 0xA "`1010"', zusammengesetzt ergibt sich für 0x7A = "`01111010"'. Die Übertragung in diesem Standard folgt dem LSB(Less significant Bit) zuerst, also werden die Bits vertauscht, demnach ergibt sich "`0101 1110"'. Davor wird eine Null hinzugefügt als Startbit und am Ende zwei Einsen als Stopbits. Demnach ergibt sich für die Übertragung des Zeichen 'z' folgenden Bitreihenfolge "`0 0101 1110 11"', die versendet wird.

\paragraph{}
Die Datenübertragung unter RS-232 ist asynchron, das bedeutet es existiert kein gemeinsamer Takt. Die Bitraten zwischen Sender und Empfänger dürfen um wenige Prozent von einander abweichen, sonst wird der Empfänger das Wort zu schnell / langsam abtasten und falsch interpretieren. Dagegen muss die Baudrate bei Sender und Empfänger genau gleich sein. Beide Begriffe sind nicht zu verwechseln. Eine Bitrate definiert die übertragenen Bits pro Sekunde und die Baudrate die übertragenen Symbole pro Sekunde, wo jedes Symbol als definierte messbare Signaländerung im physischen Übertragungsmedium definiert ist. Da die Übertragung im diesem Standard binär ist, ist ein Symbol als ein Bit definiert. Dies hat zu Folge, dass im diesem Spezialfall der Übertragung die Bitrate und die Baudrate gleich sind. Bei anderen Übertragungsarten unterscheiden sie sich jedoch.

\paragraph{}
Die Baudrate ist vom Benutzer frei wählbar. Jedoch hat der Anwender die Kabellänge, den Leitungswiderstand und die Kapazität des Kabels zu beachtet. Je länger das Kabel, desto starker nimmt die Spannung ab. Nach Erfahrungswerten von Texas Instruments ist bei einer Baudrate von 9600, eine maximale Kabellänge von 152 Meter möglich. Bei 115200 muss das Kabel kürzer als 2 Meter sein.\\

%\paragraph{}
Der Empfänger muss die Datenübertragung anhalten können, wenn er keine Daten mehr verarbeiten kann. Dieser Handshake wird softwaretechnisch oder über die Hardware mit Steuerleitungen realisiert. Bei der Softwarelösung werden am Sender spezielle Steuerzeichen gesendet. Dieses Protokoll ist als "`Xon/Xoff"' bekannt. Es ist nur möglich dieses Protokoll zu benutzen wenn die Steuerzeichen(Xon = 0x11 und Xoff = 0x13) nicht in den Nutzdaten vorkommen. Bei der Hardwarelösung signalisieren Sender und Empfänger sich gegenseitig ihren Status. Solche Protokoll besteht zum Beispiel aus fünf Steuerleitungen(TxD, RxD, GND, RTS und CTS). Damit triviale Fehler vermieden werden, müssen Sender und Empfänger die gleichen Einstellungen haben. Das heißt dass die Baudrate, Stopbits, Parität, Handshake und Kabellänge übereinstimmen müssen.


%#######################################################################################
\subsection{UART}
\paragraph{}
Universal Asynchronous Receiver Transmitter(UART) ist eine elektronische Schaltung zur Realisierung von digitalen seriellen Schnittstellen(für diese Arbeit der sogenannte COM Port). Der UART ist zum Senden und Empfangen von Daten über eine Datenleitung vorgesehen. Im industriellen Bereich ist der UART unter dem RS-232 Standard sehr verbreitet. Auch bei Wincor Nixdorf wird diese Schnittstelle zum steuern der COM Ports benutzt.

%#######################################################################################
\subsection{Paritätsbit}
\paragraph{}
Wie schon erwähnt, ist die Parität nicht im RS-232 Standard definiert, aber sie ist für diese Arbeit relevant. Das Paritätsbit dient zur Erkennung fehlerhafte Übertragungen. Die Parität kann gerade(even) oder ungerade(odd) sein und wird durch die Anzahl an Einsen in einer Bitfolge bestimmt. Ist eine gerade Parität festgelegt, wird bei einer gerade Anzahl an Einsen eine Null angehängt, bei ungerade Anzahl eine Eins. Genau das Gegenteil geschieht bei  ungerader Parität. Nach unserem Beispiel mit 0x7A wird bei gerader Parität eine Eins ("`0 0101 1110 \textbf{1} 11"') angehängt.

%#######################################################################################
\subsection{Leitungen und Stecker}
\paragraph{}
Am Anfang wurde der 25-polige D-Sub-Stecker verwendet. Viele dieser 25 Leitungen sind reine Drucker und Terminal-Steuerleitungen aus der elektromechanischen Zeit, somit sind sie für die modernere Peripherie überflüssig. So hat sich der 9-polige D-Sub-Stecker(COM Port) etabliert. Dieser Stecker war nicht ursprünglich für diesen Standard gedacht, sondern wurde von IBM als Notlösung in einem anderen Standard entwickelt, um Platz zu sparen. Der Stecker ist daher unter EIA/TIA-574 zu finden. Für die EIA-232-Datenübertragung werden selten andere Stecker benutzt.
\\
Der 9-polige D-Sub-Stecker besteht aus folgenden Leitungen:\\
\begin{tabular}{llll}
\\
TxD, TX, TD &: Transmit Data, Leitung für ausgehende Daten \\
RxD, RX, RD &: Recieve Data, Leitung für ankommende Daten \\
RTS &: Request To Send, Sendanforderung \\
CTS &: Clear To Send, Sendeerlaubnis \\
DSR &: Data Set Ready, Einsatzbereitschaft \\
GND &: Ground, Signalmasse \\
DCD, CD, RLSD &: Data Carrier Detect, Erkennung einlaufende Daten \\
DTR &: Data Terminal Ready, Datenendeinrichtung ist bereit \\
RI &: Ring Indicator, Datenverbindungsaufbau \\\\
\end{tabular}


EIA-232 ist eine Spannungsschnittstelle, also werden die logische Null und Eins durch positive oder negative Spannungen vertreten. Die Datenleitungen (TxD und RxD) benutzt eine negative Logik. Spannungen zwischen -3V und -15V repräsentieren eine logische Eins. Signale zwischen -3V und +3V gelten als nicht definierte Signale. Die logische Null wird als eine Spannung zwischen +3V und +15V interpretiert.
\\\\
Beim Empfänger, wird ein Signal zwischen +3V und +15V auf den Steuerleitungen als aktiv betrachtet, und inaktiv zwischen -3V und -15V. Beim Sender üblicherweise ±12V.
\\\\
Um Sender und Empfänger zu verbinden, gibt es verschiedene Kabelvarianten, abhängig vom Sender und vom Empfänger. Verbindet man ein Rechner (in der Regel mit einem Stecker) zu einem Modem (mit einer Buchse) ist ein 1:1 Kabel nötig. Sind zwei Rechner mit einander Verbunden, so ist die Rede von einem Nullmodemkabel, bei dem die Leitungen gekreuzt sind. Durch ein Loopback-Stecker bzw. Kurzschlussstecker wird die Sendeleitung direkt and die Empfangsleitung der gleichen Schnittstelle umgeleitet. So ein Stecker wird für die Entwicklung und deren Tests von Kommunikationsanwendungen und Hardware (UART) benutzt.


%#######################################################################################
\subsection{Verwendung der RS-232 Schnittstelle bei Wincor Nixdorf}
\paragraph{}
Die aktuellen BEETLE Systeme haben ein integrierten UART im Chipsatz. Diese COM Ports werden "`Onboard Ports"' genannt und sind "`Legacy Devices"'. Je nach System sind zwei bis sechs COM Ports eingebaut. Wenn ein Kunde weitere Schnittstellen benötigt, kann er diese über den PCI Bus die Anzahl an Ports erweitern. Diese Erweiterung findet durch eine Sunix PCI Karte mit vier oder acht COM Ports statt. Der Kunde kann auch zwei Sunix PCI Karten einbauen.
\\\\
Eine andere Erweiterungsmöglichkeit sind "`ITE"' COM Ports. Diese Ports sind direkt am PCI Bus angeschlossen und im Mainboard eingebaut. Die ITE COM Ports wurden eingebaut, weil der Super I/O in älteren Mainboards nur zwei Legacy COM Ports verwalten konnten. Um mehrere „On Board“ Ports dem Benutzer zur Verfügung zu stellen wurde der ITE Chip eingebaut. Modernere Mainboards sind in der Lage mehr als zwei COM Ports zu verwalten, und deswegen gibt es jetzt bis zu sechs Legacy Ports plus Erweiterungsmöglichkeiten.
\\\\
Die vorgestellten Schnittstellen sind für das Test Tools relevant. Es gibt noch ein anderen COM Port, der nicht in allen BEETLE Systemen vorhanden ist. Einige BEETLE Systeme haben ein iAMT (Intel Active Managment Technologie)\footnote{http://software.intel.com/en-us/articles/using-intel-amt-serial-over-lan-to-the-fullest; 30.08.2013} Chip. Dieser Port ist ein virtueller Port. Durch ein Treiber (SOL, Serial Over LAN) wird der Datenverkehr von der seriellen Schnittstelle auf das LAN umgeleitet. Da es ein virtueller Port ist, wird es nicht möglich sein, diesen Port zu testen. Die genauere Verwendung von iAMT und SOL ist für diese Arbeit nicht relevant, für mehrere Informationen wenden Sie sich an die angegebene Quelle.
\\\\
Die BEETLE Systeme benutzen die COM Ports für verschiedene Zwecke. Für die Kassensysteme, werden an den COM Ports die Scanner und Kundenanzeigen angeschlossen. So kann das BEETLE System die beiden Peripheriegeräte mit Strom versorgen und Daten senden und empfangen. Es werden auch noch Drucker an die COM Ports angeschlossen. Bei ältere BEETLE Systeme wurden die Touchkomponenten für Bildschirme an die RS-232 Schnittstelle angeschlossen. Der Bildschirm war an eine Videoschnittstelle angeschlossen und die Touchsignale wurden über ein COM Port empfangen. Im Banking Bereich werden viele verschiedene Peripheriegeräte pro System über die RS-232 Schnittstelle gesteuert und mit Strom versorgt.



%****************************************************************************************
\newpage
%****************************************************************************************





\section{Microsoft Windows API}

Die Quellen des folgenden Kapitel sind aus die MSDN Online Bibliothek \cite{SerialCommunications}, aus dem Buch "`Programming Windows"' \cite{ProgrammingWindows} und aus dem Buch "`Visual C++ 2010"'\cite{VisualC++}.

%#######################################################################################
\subsection{Definition}

\paragraph{}
Die Microsoft Windows API "`Application Programming Interface"'(Schnittstelle zur Anwendungsprogrammierung) ist ein Programmteil, dass vom Windows Betriebssystem den Benutzern und vor allem Entwicklern angeboten wird, um Programme an das Betriebssystem anbinden zu können. Ein Betriebssystem (Microsoft Windows, Mac OS, Linux, etc.) ist für Entwickler und Programmierer durch die API definiert. Somit kann eine Applikation über die API alle Funktionsaufrufe ausführen, die ein Betriebssystem anbietet. Nicht nur Funktionen sind in einer API definiert, sondern bestimmte Datenstrukturen und Datentypen durch das Kommando \textit{typedef} wie \textit{LRESULT} oder \textit{CALLBACK}.
\\

Mit fast jedem neuen Microsoft Betriebssystem wird die Windows API erweitert und abgeändert. Die erste API, bekannt als \textit{Win16}, für die 16-Bit Versionen von Microsoft Windows. Für Windows 1.0 hatte die API etwa 450 Funktionsaufrufe. Bei der Zeit von Windows 98 wurde die API auf 32-Bit und mehrere tausende Funktionsaufrufe. Ab Windows XP "`x64 Edition"' und Windows Server 2003 wurde die API auch auf 64-Bit erweitert.
\\

Der hauptsächlichen Unterschiede zwischen den 16, 32 und 64 Bit Versionen von der API entstanden durch die verschiedenen Speicher und Prozessorarchitekturen. Unter der 16-Bit Architektur war die Registergröße 16 Bit groß, diese wurde bei den Prozessoren von Intel 8086 und 8088 eingesetzt. In der 32-Bit Architektur, 32 Bit groß bzw. in der 64-Bit, 62 Bit groß. Die Windows API ist in der Programmiersprache "`C"' geschrieben. Deswegen war unter der 16-Bit Architektur der Datentyp \textit{int} "`nur"' 16 Bit lang(Zahlen von -32.768 bis 32.767) . In der Speicherverwaltung bestanden Speicheradressen aus einen 16-Bit Segment und einen 16-Bit Offset, der als Zeiger verwendet werden konnte. Für Programmierer war diese Verwaltung sehr Umständlich, da der Programmierer genaue Unterscheiden musste, zwischen \textit{long} oder \textit{far} und \textit{short} oder \textit{near} Zeiger. 
\\

Ab der 32-Bit Architektur entstand das "`Flat Memory Model"', wo der Prozessor direkt die gesamte Speicheradressen ansprechen konnte, ohne Speichersegmentierung oder Pagingschemas. Somit wurde auch der \textit{int} Datentyp auf 32 Bitgröße (Zahlen von -2.147.483.649 bis 2.147.483.647) definiert. Programme, die auf einem System mit einer 32-Bit Architektur geschrieben worden sind, benutzen einfache Zeigerwerte um direkt die Speicheradresse ansprechen zu können. Bei der Umstellung von 16-Bit auf 32-Bit blieben viele Funktionsaufrufe gleich, aber manche brauchten eine Umstellung auf 32-Bit, wie zum Beispiel das graphische Koordinatensystem für die GUI Darstellungen.
\\

Aus Kompatibilitätsgründe sind die API's Rückwärts kompatibel. Die Kompatibilität entsteht durch eine Übersetzungsschicht. Es gibt zwei Wege der Übersetzung. Im ersten Weg, werden 16-Bit Funktionsaufrufe durch eine Übersetzungsschicht in 32-Bit Funktionsaufrufe umgewandelt und dann vom Betriebssystem bearbeitet. Der andere Weg führt genau in die andere Richtung. Die 32-Bit Funktionsaufrufe werden durch die Übersetzungsschicht übersetzt und wandelt diese in 16-Bit Funktionsaufrufe um, und werden dann vom Betriebssystem bearbeitet.
\\

Die Benutzung der API ist nicht die einzige Möglichkeit, Anwendung für die Windowsbetriebssysteme zu programmieren, aber durch die Benutzung der API ist eine bessere Effizienz gewährleistet. Die Anwendungen können auch in Visual Basic oder Borland Delphi geschrieben werden, wo die objektorientierten Grundlagen von Pascal dem Programmierer viel Arbeit abnehmen. Durch Verschachtelungen mehrerer Programmierschichten, die im Endeffekt auf die  API zugreifen, verlangsamen das Programm und im späteren Verlauf der Leistungsoptimierung des Programmes wird der Programmierer früher oder später mit der Komplexität der API konfrontiert.

%----------------------------------------------------------------------------------------------
\subsubsection{API gegenüber .NET Framework}
\paragraph{}
Microsoft hat dieses Framework speziell für die Windows-Plattformen entwickelt. Es ist eine Virtuelle Maschine mit einer Laufzeitumgebung für Microsoft Windows Anwendungen. Dieses Framework ähnelt in vielen Teilen der Java Virtual Machine. Das .NET Framework besteht aus eine Laufzeitumgebung und der .NET Framework-Bibliothek. Aus Sicht des Anwenders hat sich nichts geändert, aber für die Programmierer vieles. Das .NET Framework ist auf C++ und C\# basierend und im Gegensatz zur API, objektorientiert. Die Framework-Bibliothek besteht aus verschiedenen Klassenbibliotheken, wie zum Beipiel die Windows Forms, Windows Presentation Foundations (GUI), Webdienste,... . Ein großer Vorteil ist die Portierung der Programme, dafür muss aber das .NET Framework installiert sein. Das ist für dieses Projekt essentiell, denn es soll auf Schreibgeschütze Medien ausführbar sein (Win PE) und aus diesem Grund wird es von mir nicht verwendet.




%#######################################################################################
\subsection{Windows.h}
\paragraph{}
Die Window.h Headerdatei ist die Masterdatei, die alle anderen Headerdateien inkludiert. In diesen Dateien sind die Funktionsaufrufe, Konstanten, Typdefinitionen und Datenstrukturen für das Windowsbetriebssystem definiert. Diese Headerdateien sind Teil der Dokumentation der API. Im Folgenden sind ein Paar Headerdateien aufgeführt die in der Windwos.h inkludiert werden:

\begin{tabular}{llll}
\textbullet & WINBASE.H & Kernenfunktionen\\
\textbullet & WINDEF.H  & Typdefinitionen\\
\textbullet & WINNT.H  & Typdefinitionen mit Unicode Unterstützung\\
\textbullet & WINUSER.H  & Funktionen für die Benutzerschnittstelle\\
\textbullet & WINGDI.H  & Graphische Schnittstelle\\
\end{tabular}

%#######################################################################################
\subsection{WinMain}
\paragraph{}
\textit{C/C++} Programme fangen mit eine \textit{int main()} Funktion an. Da die API auf \textit{C} basiert, fangen Anwendungen mit Windows als Zielsystem mit einer ähnliche Funktion an. Unter Windows ist die \textit{main} Funktion unter "`WINBASE.H"' als:

\begin{tabbing}

int WINAPI \=WinMain(\\
    			\>HINSTANCE hInstance,\\
    			\>HINSTANCE hPrevInstance,\\
    			\>LPSTR lpCmdLine,\\
    			\>int nShowCmd\\
			\>);
\\
\end{tabbing}

Der Bezeichner \textit{WINAPI} beschreibt einen Datentyp. Dieser Datentyp ist definiert als \textit{WINAPI \_\_stdcall}. \textit{\_\_stdcall} ist eine Aufrufkonvention um Funktionen aus der Win32 API aufzurufen. Die \textit{WinMain} Funktion bekommt als Parameter zwei \textit{HINSTANCE} Variablen, ein \textit{LPSTR} (Zeiger auf eine Zeichenkette) und ein \textit{int}.\\


\textit{HINSTANCE} ist ein Handle auf eine Instanz. Das ist die Basisadresse von einem Modul im Systemspeicher(eine 32-Bitzahl, dass auf ein Objekt zeigt). Der erste Parameter ist eine Instanz auf die aktuelle Anwendung. Der zweiter Parameter wurde nur unter Win16 benutzt und ist in der Win32 API irrelevant, er wird automatisch auf \textit{NULL} gesetzt. Der dritte Parameter enthält die Befehlszeilenargumente als Zeichenfolge. Aus dieser Zeichenfolge wertet das Programm aus, wie es ausgeführt werden soll. Der vierte und letzte Parameter ist ein Flag und gibt an, wie das Anwendungsfenster angezeigt werden soll (Minimiert, Maximiert oder Normalgröße).

%#######################################################################################
\subsection{Graphic User Interface (GUI)}
\paragraph{}
Durch die Begrenzung der einzubauenden Hardware in den frühen Jahren des Computerzeitalters (Speicher und Prozessoren) waren alle Betriebssysteme Kommandozeileorientiert. Dies sollte sich aber ändern durch die Recherche von Xerox Palo Alto Research Center(PARC). Mitte der 70 Jahren wurde im Xerox PARC nach graphische Benutzeroberflächen recherchiert. Aus diesen Ergebnissen profitierten Macintosh und Windows, und bauten darauf ihre Betriebssysteme mit graphischen Benutzeroberflächen(Mac OS und Windows). Heutzutage kann man sich als Benutzer kaum eine Computerwelt ohne Benutzeroberflächen vorstellen. Die Windows API hat seit der Ankündigung(1983) und Veröffentlichung(1985) von Windows als Betriebssystem Funktionsaufrufe in die Headerdateien für die Programmierung von GUI's. Die Benutzung der API für die Programmierung von GUI's ist vielleicht "altmodisch", aber immerhin sehr genau und präzise. Im Gegensatz zu "`GUI Builders"' wird kein unnötiger, und oft für Programmierer, unverständlicher Code geschrieben. Der Überblick und Verständnis der GUI Elemente wird durch die direkte Benutzung der API vereinfacht. Vor allem wird das Verständnis wie eigentlich eine GUI unter Windows und Windows als Betriebssystem funktioniert, durch die Verwendung der API deutlicher.

%#######################################################################################
\subsection{Aufbau einer GUI}
\paragraph{}
Nachdem die \textit{WinMain} Funktion die nötigen Parameter bekommt und diese vom Programm ausgewertet werden, muss die GUI als solche gebaut und registriert werden. Eine GUI besteht aus drei Teilen.


%----------------------------------------------------------------------------------------------
\subsubsection{Initialisierung und Erzeugung der GUI}\label{Ini und Erzeugung}
\paragraph{}
Damit der Benutzer ein Programmfenster sehen kann, muss dieses zuerst deklariert und initialisiert werden. Danach wird dieses Fenster dem System bekannt gegeben, in dem es registriert wird. Um ein Fenster zu deklarieren muss eine Variable der Struktur \textit{WNDCLASS} erzeugt werden. Diese Struktur wird in \textit{WINUSER.H} definiert und beinhaltet verschiedene Variablen, die die Eigenschaften des jeweiliges Fenster beschreiben.



\begin{tabular}{llll}
& typedef struct\\
& \{\\
& & UINT        & style ;\\
& & WNDPROC     & lpfnWndProc ;\\
& & int         & cbClsExtra ;\\
& & int         & cbWndExtra ;\\
& & HINSTANCE   & hInstance ;\\
& & HICON       & hIcon ;\\
& & HCURSOR     & hCursor ;\\
& & HBRUSH      & hbrBackground ;\\
& & LPCTSTR     & lpszMenuName ;\\
& & LPCTSTR     & lpszClassName ;\\
&\}WNDCLASS,&* PWNDCLASS ;
\end{tabular}

Die zwei wichtigsten Variablen dieser Struktur ist die Zweite und die Letzte Variable. Die zweite Variable \textit{WNDPROC lpfnWndProc} beschreibt die Fensterprozedur. Genaueres zu dieser Variable wird demnächst erklärt. Die letzte Variable \textit{LPCSTR lpszClassName}, beschreibt die Klasse des Fensters. Die Variable \textit{HINSTANCE hInstance} muss dem Leser bekannt sein. Diese Variable wird auf den Wert gesetzt, welches das Programm über die \textit{WinMain} bekommen hat. Alle andere Variablen der Struktur beschreiben wie das Fenster aussehen soll und sind für das Verständnis weiterhin irrelevant.
\\
Nachdem die \textit{WNDCLASS} Struktur deklariert und initialisiert wird, muss diese registriert werden. Durch den Aufruf der Funktion \textit{RegisterClass}, die als Übergabeparameter einen Zeiger auf eine \textit{WNDCLASS} Struktur hat, wird dem System bekannt gegeben, dass ein Fenster aufgebaut werden soll (mit dem gesetzten Eigenschaften der \textit{WNDCLASS} Struktur). Wenn das Registrieren erfolgreich war, muss das Fenster noch erzeugt werden. Das System kennt das Fenster, aber es ist noch nicht sichtbar.\\

Damit ein Fenster sichtbar wird, muss der Programmierer die \textit{CreateWindow}\footnote{http://msdn.microsoft.com/en-us/library/windows/desktop/ms632679(v=vs.85).aspx; 27.08.2013} Funktion aufrufen. 


\begin{tabular}{llll}
&HWND WINAPI CreateWindow (&\\
& & In\_opt & LPCTSTR lpClassName,\\
& & In\_opt & LPCTSTR lpWindowName,\\
& & In      & DWORD dwStyle,\\
& & In      & int x,\\
& & In      & int y,\\
& & In      & int nWidth,\\
& & In      & int nHeight,\\
& & In\_opt & HWND hWndParent,\\
& & In\_opt & HMENU hMenu,\\
& & In\_opt & HINSTANCE hInstance,\\
& & In\_opt & LPVOID lpParam\\
&);
\end{tabular}

Diese Funktion ist sehr wichtig bei der Erzeugung von graphischen Oberflächen, denn man kann alle Arten von Fenstern damit erzeugen. Damit ist gemeint, dass diese Funktion  nicht nur "`Hauptfenster"', sondern auch die einzelnen GUI Elemente erzeugt. Der erste Parameter beschreibt dieses Verhalten. Die \textit{CreateWindow} Funktion erwartet eine null terminierte Zeichenkette. Diese Zeichenkette ist immer eine vordefinierte Systemklasse. Zum Beispiel, um ein Schaltfläche zu erstellen, muss hier als Parameter "`button"' angegeben werden. Wenn der Programmierer ein von ihm erzeugtes Fenster darstellen will, muss er deswegen vorher im System eine Fensterklasse registrieren. Aus diesem Grund muss der Programmierer eine Fensterstruktur \textit{WNDCLASS} registrieren. Um danach ein selbst gebautes Fenster zu erzeugen, muss der Programmieren den registrierten Fensterklassenname(\textit{WNDCLASS lpszClassName}) angeben (anstatt "`button"' oder andere vordefinierte Fensterklassen).\\

Der zweite Parameter beschreibt der dargestellter Name des Fenster. \textit{DWORD dwStyle} ist eine Bitmaske, die die Darstellungsart des Fensters beschreibt. Die Darstellungsarten sind als konstante Werte (Window Styles\footnote{http://msdn.microsoft.com/en-us/library/windows/desktop/ms632600(v=vs.85).aspx; 27.08.2013})in der \textit{WINUSER.H} Headerdatei definiert. Um ein "`traditioneles"' Fenster zu erzeugen muss hier \textit{WS\_OVERLAPPEDWINDOW} angegeben werden. Die Nächste vier Parameter beschreiben die Positionierung im Bildschirm und die Breite und Höhe des Fensters.\\ 


\textit{HWND hWndParent} beschreibt ein Handle auf ein anderes Fenster. Im Falle, dass dieses Fenster das Hauptfenster ist, wird hier NULL übergeben, sonst muss das Handle auf das "`Parent Windows"' zeigen. Das \textit{HMENU hMenu} ist für das Hauptfenster irrelevant. Es ist aber wichtig für Unterfenster(Popup Fenster oder GUI Elemente wie Knöpfe). \textit{HMENU} ist eine Typdefinition für ein Handle auf ein Fenstermenü oder ein Unterfenster. Somit kann das Hauptfenster ein Kommando eines GUI Elements erkennen und auswerten, mehr dazu im Kapitel ~\ref{message-loop}. Da auf den Parameter \textit{HINSTANCE hInstance} im Vorlauf schon drauf eingegangen wurde wird er hier nicht mehr auf ihn drauf eingegangen. Der letzte Parameter beinhaltet Extrainformation, üblicherweise wird hier NULL angegeben.\\

Die \textit{CreateWindow} Funktion liefert als Rückgabewert ein \textit{HWND}. Dies steht für Handle auf ein Fenster. Somit kann der Programmierer und das Programm auf ein gewünschtes Fenster zugreifen. Um die erwähnten Parameter genauer zu verstehen, werden diese in den folgenden Beispiele erläutert. 

\begin{tabular}{llll}
& HWND hwnd\_Fenster = CreateWindow (\\
\\
& szAwendungsName,					& //Fensterklasse vom Programmierer registriert\\                            
& "Das ist eine Hauptfenster",  	& //Text auf der Titelleiste\\                                
& WS\_OVERLAPPEDWINDOW,              & //Stil des Fensters\\                         
& CW\_USEDEFAULT,                    & //Position in der X Koordinate des Bildschirmes\\     
& CW\_USEDEFAULT,                    & //Position in der Y Koordinate des Bildschirmes\\     
& CW\_USEDEFAULT,                    & //Lange des Fensters\\                                  
& CW\_USEDEFAULT,                    & //Breite des Fensters\\                                 
& NULL,                              & //Kein zugehöriges Hauptfenster\\                           
& NULL,                              & //Keine Identifikationsnummer\\                               
& hInstance,                         & //Programminstanz\\                                 
& NULL                               & //keine extra Information\\  
& );                          
\end{tabular}                        
Um verschiedene GUI Elemente im Hauptfenster darstellen zu können, wie z.B. eine Schaltfläche, muss die Funktion mit den folgenden Parametern gesetzt werden:
\\
\begin{tabular}{llll}
& HWND Schaltfläche = CreateWindow (\\
\\
& "button",					& //Fensterklasse Schaltfläche\\
& "Das ist eine Schaltfläche",		& //Text auf den Schaltfläche\\
& WS\_CHILD | WS\_VISIBLE,	& //Child Fenster und anzeigen\\
& 100,						& //Position in der X Koordinate des Hauptfensters\\
& 100,						& //Position in der Y Koordinate des Hauptfensters\\
& 50,						& //Länge der Schaltfläche\\
& 35,						& //Breite der Schaltfläche\\
& hwnd\_Fenster,				& //Zugehöriges Hauptfenster\\
& (HMENU) ID\_Schaltfläche,			& //Identifikationsnummer, wird vorher deklariert\\
& NULL,						& //keine Instanz\\
& NULL						& //keine extra Information\\
& );
\end{tabular}

Nachdem ein Hauptfenster erzeugt worden ist, muss dieses noch explizit mittels der Funktionen \textit{ShowWindow(hwnd\_Fenster, iCmdShow)} und \textit{UpdateWindow(hwnd\_Fenster)}	angezeigt werden.

%----------------------------------------------------------------------------------------------				
\subsubsection{Die Message Loop}\label{message-loop}
\paragraph{}
Nachrichten zwischen verschiedenen Programmen werden unter Windows in sog. Nachrichtenschleifen, auch \textit{message loop} genannt, verarbeitet. In diesen \textit{message loops}  werden Events von Schaltflächen oder Tastatureingaben ausgewertet und dem entsprechend reagiert. Die ausgelösten Events werden von Windows in eine Nachricht übersetzt, jede dieser Nachrichten ist eindeutig durch eine \textit{MSG} Struktur beschrieben und eindeutig identifizierbar, diese wird anschließend in die \textit{message loop} hineingeschrieben und wenn möglich verarbeitet. Wird eine neue ankommende Nachricht empfangen während eine andere Nachricht bearbeitet wird, wird die neue Nachricht in die sog. "`Message Queue"'(Warteschlange) geschrieben. 

\begin{tabular}{llll}
& typedef & struct tagMSG\\
& \{\\
&  & HWND   & hwnd ;\\
&  & UINT   & message ;\\
&  & WPARAM & wParam ;\\
&  & LPARAM & lParam ;\\
&  & DWORD  & time ;\\
&  & POINT  & pt ;\\
& \}\\
& MSG,&* PMSG;\\
\end{tabular}

Jede Nachricht hat als ersten Parameter ein Handle auf das zugehörige Fenster. Danach wird als zweiter Parameter ein \textit{unsigned int (UINT)} übergeben, welches als ID der jeweiligen Nachricht zu verstehen ist. Diese Nachrichten sind in \textit{WINUSER.H} deklariert und habe den Präfix \textit{WM}, welches für "`Window Message"' steht. Zum Beispiel wird ein Mausklick einem Fenster ausgelöst, sendet Windows eine Nachricht an das Fenster(durch \textit{hwnd} angegeben) mit der Nachricht \textit{WM\_RBUTTONDOWN}.\\

Die Parameter \textit{wParam} und \textit{lParam} sind 32-Bit Nachrichtenparametern, abhängig von der jeweiligen Nachricht. Wird zum Beispiel auf eine Schaltfläche gedrückt, wird die \textit{WM\_COMMAND} Nachricht verschickt. Damit die Anwendung genau erkennen kann welche Aktion ausgeführt worden ist, wird in \textit{wParam} noch eine zwei Angabe mitgeschickt. In den oberen 16-Bits wird die Notifikation \textit{BN\_CLICKED} verschickt. Dies deutet an, dass ein Schaltfläche geklickt worden ist. In den unteren 16-Bits von \textit{wParam} wird die Identifikationsnummer(nach den obigen Beispiel: ID\_Schaltfläche) der Schaltfläche mitgeschickt. Mit diesen Informationen kann ein Programm genau auf die vom Benutzer ausgelösten Events reagieren. Beide 16-Bit Werte werden mit Hilfe der Makros \textit{HIWORD} \footnote{http://msdn.microsoft.com/en-us/library/windows/desktop/ms632657(v=vs.85).aspx; 27.08.2013} und \textit{LOWORD} \footnote{http://msdn.microsoft.com/en-us/library/windows/desktop/ms632659(v=vs.85).aspx; 27.08.2013} ausgewertet.\\

Der Parameter \textit{time} gibt die Uhrzeit an, wann die Nachricht verschickt worden ist. Der Parameter \textit{pt} ist eine \textit{POINT} Struktur, wo die X und Y Koordinaten des Mausklicks gespeichert sind. Mit diesen Informationen erkennt das Fenster welche Schaltfläche betätigt wurde.
\\\\
Eine Nachrichten Schleife ist standardmäßig so aufgebaut:

\begin{tabular}{llll}
while & (GetMessage (\&msg, NULL, 0, 0))\\
\{\\
     & TranslateMessage (\&msg) ;\\
     & DispatchMessage (\&msg) ;\\
\}\\
\end{tabular}

Die \textit{GetMessage} Funktion speichert in der \textit{msg} Struktur die aktuelle Nachricht. Die drei anderen Parameter spezifizieren, dass alle Nachrichten(von der jeweilige Anwendung) in die Schleife geschrieben werden. Die Funktion liefert immer ein Wert ungleich Null, außer wenn die Nachricht \textit{WM\_QUIT} lautet, denn damit wird die Schleife verlassen und das Programm beendet.
\\
Die Funktion \textit{TranslateMessage} gibt die Nachricht an das Betriebssystem weiter und übersetzt die virtuellen Tasten-Nachrichten auf tatsächliche Zeichen\footnote{http://msdn.microsoft.com/en-us/library/windows/desktop/ms644955(v=vs.85).aspx; 27.08.2013}. Die \textit{DispachtMessage} Funktion gibt die Nachricht an Windows weiter, dabei wird die richtige Fensterprozedur (\textit{WndProc} wird später erklärt)aufgerufen. Wenn die Fensterprozedur die Nachricht bearbeitet hat, wird die Nachricht zurück an Windows gesendet.  Danach gibt Windows die bearbeitete Nachricht weiter an die jeweilige Anwendung und so kann die Schleife die nächste Nachricht laden und bearbeiten.



%----------------------------------------------------------------------------------------------
\subsubsection{Fensterprozedur: WndProc Funktion}
\paragraph{}

Im vorigen Unterkapitel ~\ref{Ini und Erzeugung} wurde die schon einmal Fensterprozedur erwähnt, aber noch nicht detailliert auf sie eingegangen, in diesem Kapitel wird nun näher auf deren Eigenschaften und dessen Funktionen eingegangen. Der Name der Funktion kann wie eine Variable gehandhabt werden. In dieser Variable sind die Nachrichten die das jeweilige Fenster bearbeitet. Das hat zur Folge, dass eine Fensterstruktur die als \textit{WNDCLASS wc} deklariert und mit den folgenden Parametern \textit{WNDPROC lpfnWndProc} initialisiert \textit{wc.lpfnWndProc = WndProc;} ist, muss die Fensterprozedur für dieses Fenster \textit{WndProc} heißen. Wie die Fensterprozedur heißt ist irrelevant, solange die Namen in der Fensterklasse und die Prozedur übereinstimmen, somit sind Fenster und Prozedur verbunden. Eine Fensterprozedur wird wie folgt definiert:

\begin{tabular}{ll}
LRESULT CALLBACK & WndProc(\\
& HWND hwnd,\\
& UINT message,\\
& WPARAM wParam,\\
& LPARAM lParam);
\end{tabular}

Der Datentyp \textit{CALLBACK} ist schon aus den vorigen Kapiteln bekannt und \textit{LRESULT} ist eine Typdefinition vom Typ \textit{long}. Die vier Parameter der Funktion sind die gleichen wie die ersten vier Parameter bei einer \textit{MSG} Struktur. Falls ein Programm mehrere Fenster von der gleichen Fensterklasse hat, spezifiziert der erste Parameter welches Fenster(Handle) die Nachricht schickt. Programme rufen die Fensterprozedur in der Regel nicht auf, sondern Windows. Will ein Programm die Prozedur direkt aufrufen, dann wird die Funktion \textit{SendMessage} benutzt. Auf diese Methode wird im Folgenden drauf eingegangen.
\\

Eine selbst geschrieben Fensterprozedur hat den Vorteil, dass ein Programm auf die Event reagiert, auf die man reagieren möchte. Es müssen nicht alle Event programmiert werden. Um vorzubeugen, dass Nachrichten unbearbeitet bleiben, wird am Ende der selbstgeschriebenen Fensterprozedur die\textit{DefWindowProc} Funktion aufgerufen. Diese Methode bearbeitet alle mögliche Nachrichten und ist die default Fensterprozedur. Wenn diese Funktion nicht aufgerufen wird, werden grundlegende Funktionen in einer GUI nicht funktionieren.
\\

Die erste Nachricht die eine Fensterprozedur bekommt ist die \textit{WM\_CREATE} Nachricht. Hier baut der Programmierer alle GUI Elemente auf, mit Hilfe der \textit{CreateWindow} Funktion(Schaltfläche Beispiel). Eine zweite wichtige Nachricht ist die \textit{WM\_DESTROY} Nachricht. Diese Nachricht wird verschickt wenn der Benutzer ein Fenster schließen möchte. Der Programmierer ruft die \textit{PostQuitMessage(0)} Funktion auf und automatisch wird eine \textit{WM\_QUIT} Nachricht verschickt. Somit wird das Fenster geschlossen, die Message Loop verlassen und das Programm bzw. Fenster richtig beendet.
\\

Es gibt noch weitere Nachrichten, die man "`manuell"' verschicken kann. Mit Hilfe der erwähnten Funktion \textit{SendMessage} \footnote{http://msdn.microsoft.com/en-us/library/windows/desktop/ms644950(v=vs.85).aspx; 28.08.2013}. Die Funktion hat die gleichen Parameter wie eine Fensterprozedur. Durch das Handle wird angegeben, an welches Fenster die Nachricht verschickt werden soll. Durch den zweiten Parameter wird angegeben, welche Nachricht verschickt wird, und die letzten zwei sind Extrainformationen der Nachricht(wenn nötig). Möchte man im Ablauf des Programms zum Beispiel der Darstellungstext von unserer Schaltfläche ändern, wird die \textit{SendMessage} Funktion so aufgerufen:

\begin{center}
SendMessage(hwnd\_Schaltfläche, WM\_SETTEXT, 0, (lParam)"NeuerText");
\end{center}

%----------------------------------------------------------------------------------------------
\subsection{Die RS-232 Schnittstelle und die Windows API}\label{COMWINAPI}
\paragraph{}
Über die Windows API hat man direkt Zugriff auf die RS-232 Schnittstelle. Zum Verwalten der Schnittstelle und zum Setzen der Eigenschaften gibt es verschiedene Datenstrukturen, die man aufrufen und ändern muss je nach Bedarf.

%----------------------------------------------------------------------------------------------
\subsubsection{Öffnen und Schließen eines Ports}
\paragraph{}
Um Zugriff auf die Datenstrukturen zu bekommen, muss zuerst eine RS-232 Schnittstelle (COM Port) geöffnet. Durch die Funktion \textit{CreateFile}{http://msdn.microsoft.com/en-us/library/windows/desktop/aa363858(v=vs.85).aspx; 25.08.2013} bekommt man ein Handle auf den angegeben Port. Ein Handle ist eine Referenzwert zu einer vom Betriebssystem verwalteten Systemressource, in diesem Fall eine im System vorhandene RS-232 Schnittstelle. Mit \textit{CreateFile} kann man auch Zugriff auf Dateien, Datenstreams und andere Kommunikationsressourcen bekommen. Das Handle muss gespeichert werden, denn damit wird der jeweiliger Port identifiziert und angesprochen für weitere Operationen. Durch die \textit{CreateFile} Funktion wird die Datei oder in diesem Fall die Input / Output Schnittstelle für diese Anwendung reserviert. Das heißt, für das Betriebssystem und andere Anwendungen steht diese Schnittstelle nicht mehr zur Verfügung.
\\

Um den richtigen Zugriff auf einen Port zu haben, müssen auch die richtigen Flags bei dem Aufruf der \textit{CreateFile} Funktion angegeben werden. Als Flags sind die folgende Parameter anzugeben:
\begin{itemize}
\item Schreib und Leserechte
\item Non-Sharing Modus
\item Öffnen vor nur existierende Schnittstellen
\item Asynchron Modus
\end{itemize}

Um ein Programm "`sauber"' zu beenden, müssen offene Handles geschlossen werden. Durch die Funktion \textit{CloseHandle}\footnote{http://msdn.microsoft.com/en-us/library/windows/desktop/ms724211(v=vs.85).aspx; 25.08.2013} mit Angabe eines gültiges Handles wird dieses geschlossen und steht für das Betriebssystem und andere Anwendungen wieder zur Verfügung.


%----------------------------------------------------------------------------------------------
\subsubsection{Konfiguration eines Ports}
\paragraph{}
Es gibt drei wichtige Strukturen, die für die Konfiguration einer COM Schnittstelle relevant sind. Mittels dieser Strukturen werden die Eigenschaften, einstellbare Parameter und Wartezeiten einer Schnittstelle eingestellt.
\\

Die \textit{DCB}\footnote{http://msdn.microsoft.com/en-us/library/windows/desktop/aa363214(v=vs.85).aspx; 28.08.2013} Struktur definiert die Ansteuerungseigenschaften für die Schnittstelle. Um die Struktur für eine angegebene Schnittstelle zu laden, wird die Funktion \textit{GetCommState} aufgerufen. Diese Struktur besteht aus 28 verschiedene Variablen. Diese Variablen beschreiben wie die Schnittstelle konfiguriert ist. Man kann die Baudrate, Parität, Stopbits, Datenbits, Flusssteuerung und Fehlerbenachrichtigung einstellen.
\\

Um die Schnittstelle richtig einzustellen und keine falsche Eingaben in die \textit{DCB} Struktur zu schreiben, ist es sinnvoll vorher die \textit{COMMPROP} \footnote{http://msdn.microsoft.com/en-us/library/windows/desktop/aa363189(v=vs.85).aspx; 28.08.2013} Struktur auszuwerten. Durch die Funktion \textit{GetCommProperties} wird die Struktur für die angegebene Schnittstelle geladen. Diese Struktur besteht aus 18 Variablen und beschreibt die möglichen Einstellungen für diese Schnittstelle. Die Einstellungen werden aus dem Treiber der jeweiliger Schnittstelle(Onboard Ports, Sunix, Intel SOL oder ITE) gelesen. Die für diese Arbeit relevanten Parameter ist die maximale einstellbare Baudrate.
%wSettableStopParity
%dwSettableParams
\\

Während der Übertragung von Daten über eine serielle Schnittstelle sind maximale Wartezeiten fällig. Dieses Werte entstehen durch die Übertragungslänge und der eingestellten Baudrate. Auch die Wartezeit zwischen zwei ankommenden Bytes ist wichtig um das Ende der Übertragung bestimmen zu können. Diese Werte sollten dynamisch berechnet werden und danach in die Schnittstelle eingestellt werden. Dafür ist die \textit{COMMTIMEOUTS} \footnote{http://msdn.microsoft.com/en-us/library/windows/desktop/aa363190(v=vs.85).aspx; 28.08.2013} Struktur zuständig. Die Struktur besteht aus fünf Variablen, die die Wartezeiten in Millisekunden angeben. Die erste Variable beschreibt die Zeitüberschreitung zwischen zwei ankommende Bytes, wird dieser Wert überschritten, so wird die Leseoperation beendet. Der zweite und vierte Parameter(jeweils für Lesen und Schreiben) beschreiben die Zeit, die für die Übertragung aller Bytes nötig ist(für die aktuelle Schreibe- oder Leseoperation). Diese Parametern sind von der Baudrate und der Bitlänge eines Zeichens abhängig. Damit ist gemeint, wie unter 3.1.2 erläutert, ein Zeichen kann aus 8 Bits plus Startbit, Stopbit und Parität bestehen. Also werden nicht genau 8 Bits(1 Byte) per Charakter, sondern oft mehr (11 Bits zum Beispiel) übertragen. Die Wartezeit wird durch die folgende Formel berechnet:

\begin{center}
$ Wartezeit = \frac{Anzahl der Bits}{Baudrate} \times 1.1$
\end{center}

In der Formel wird mal 1.1 multipliziert um eine 10\% Kulanz zu haben. Der dritte und fünfte Parameter sind eine extra Wartezeit, für jeweils Lesen und Schreiben, die zu der gesamte berechnete Wartezeit pro Lese-/Schreibvorgang addiert wird. Falls der berechnete Wert unter zehn Millisekunden ist, wird dieser auf zehn Millisekunden gesetzt.
\\

Wenn ein Port geöffnet wird, muss die Art der Kommunikation angeben werden. Die Kommunikation zwischen den Schnittstellen kann synchron(nonoverlapped) oder asynchron(overlapped) erfolgen. Für diese Arbeit habe ich mich für asynchrone Kommunikation entschieden. Dieser Art der Kommunikation ist etwas komplexer, bietet aber mehr Flexibilität und Effizienz.



%----------------------------------------------------------------------------------------------
\subsubsection{Lesen und Schreiben}
\paragraph{}
Nachdem ein Port konfiguriert ist, wie es nötig ist, kann man diesen Port benutzen um Informationen zu schicken oder zu empfangen. Um in einen Port schreiben oder aus einem Port lesen zu können  werden zwei verschiedene Funktionen benötigt. Um in einen Port zu schreiben wird die Funktion \textit{WriteFile}\footnote{http://msdn.microsoft.com/en-us/library/windows/desktop/aa365747(v=vs.85).aspx; 28.08..2013} benötigt. Diese Funktion benötigt als ersten Parameter das Handle auf den geöffnete Port. Als zweiten muss angegeben werden, welche Information geschrieben werden soll und die Größe dieser Information in Bytes. Als optionale Parameter kann man einen Zeiger wo die Menge der geschriebene Bytes geschrieben wird und ein Zeiger zu einer \textit{OVERLAPPED} Struktur übergeben. Die Kommunikation zwischen Ports in dieser Arbeit ist Asynchron, deswegen wird hier eine Zeiger auf eine Struktur übergeben.
\\

Das Lesen aus einem Port geschieht sehr ähnlich. Die Funktion dafür heißt \textit{ReadFile}\footnote{http://msdn.microsoft.com/en-us/library/windows/desktop/aa365467(v=vs.85).aspx; 28.08.2013}. Die Lesefunktion benötigt genau die gleichen Parameter wie die Schreibfunktion. Da die Lese und Schreibvorgänge sehr ähnlich sind, ist der Aufbau beider Funktionsaufrufe auch ähnlich. Um aus einem Port zu lesen oder schreiben muss zuerst eine \textit{OVERLAPPED} Struktur deklariert werden. Somit versichern wir uns, dass die Kommunikation asynchron ist. Danach muss in der Struktur der Parameter \textit{hEvent} initialisiert werden. Dieser Parameter ist ein Handle auf ein Event. Ein Event in diesem Fall ist der Schreibe- oder Lesevorgang. Durch dieses Event kann der Status von dem Vorgang abgefragt werden. Als erstes wird die jeweilige Lese- oder Schreibfunktion aufgerufen. Wenn dieser Vorgang erfolgreich war, muss der Status abgefragt werden, um sicher zu sein, dass der Vorgang vollständig ist. Im Fall, dass sich das Schreiben oder Lesen noch verzögert, muss auf die Beendigung des Events gewartet werden. Zuerst muss abgefragt werden, ob ein Fehler entstanden ist. Wenn der Fehler \textit{ERROR\_IO\_PENDING} heißt muss das Programm noch warten, sonst ist ein anderer Fehler entstanden. Um auf das Beenden eines Events zu warten und zu reagieren, wird die Funktion \textit{WaitForSingleObject}\footnote{http://msdn.microsoft.com/en-us/library/windows/desktop/ms687032(v=vs.85).aspx; 28.08.2013} aufgerufen. Diese Funktion wartet bis das angegebene Event(lesen oder schreiben) sein Status ändert oder nach einer bestimmten Zeit abläuft. Diese Zeit ist der Timeout, welcher vorher berechnet wurde. Wenn die Zeit abgelaufen ist, wir ein Timeout Fehler ausgegeben. Das heißt, das Programm muss noch warten. Ändert sich der Status des Events, bevor die Zeit abläuft wird mittels der Funktion \textit{GetOverlappedResult}\footnote{http://msdn.microsoft.com/en-us/library/windows/desktop/ms683209(v=vs.85).aspx; 28.08.2013} das Event noch abgefragt. Diese Funktion muss das Handle des Ports, sowie die \textit{OVERLAPPED} Struktur und die Anzahl an Bytes die transferiert werden sollten, angeben. Wenn diese Funktion keine Fehler meldet, dann wurde der jeweilige Vorgang erfolgreich abgeschlossen. Im Fall eines Schreibvorgang, muss sichergestellt werden, dass alle Bytes geschrieben worden sind. Wird ein Lesevorgang durchgeführt, muss sicher gestellt werden, dass die komplette Information angekommen ist, bevor gelesen wird. Es kann daher zu Timeout Fehler kommen. Um solche Fehler nicht als Abbruchbedingung zu melden, wird nach einer Vereinbarung mit dem Auftragsgeber, fünf mal versucht die Zeichen zu lesen oder zu schreiben. Wenn danach der Fehlern noch vorliegt, wird dieser gemeldet.