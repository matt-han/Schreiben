\chapter{Fachlichesumfeld}\label{chp:fachlichesumfeld}

\section{RS-232 (Radio Sector 232)}

Die Quellen dieses Kapitel sind aus "`http://de.wikipedia.org/wiki/RS-232; 25.08.2013"' und "`Joe Campbell: V 24 / RS-232 Kommunikation. 4. Auflage. Sybex-Verlag GmbH"'.

\paragraph{}
Der RS-232 ist ein Standard der in den 60er Jahren von dem US-amerikanischen Standardisierungskomitee Electronic Industries Association(EIA) bearbeitet?? (entwickelt) und definiert wurde. Bei diesem Standard handelt es sich um eine serielle Schnittstelle, die für die serielle Kommunikation zwischen Rechnern und Modems für eine Punkt-zu-Punkt Verbindung (über Telefonleitungen) entwickelt wurde.


%#######################################################################################
\subsection{Definition}
\paragraph{}

Der RS-232 Standard definiert eine Verbindung zwischen einer Datenendeinrichtung (DEE, zum Beispiel das Terminal) und einer Datenübertragungseinrichtung (DÜE, zum Beispiel einem Modem) und dessen Parameter. Unter den einzelnen Parametern sind folgende Eigenschaften zu verstehen:
\begin{enumerate}
\item Spannungspegel
\item Übertragungsprotokoll (Handshake)
\item Stecker
\item Timing
\end{enumerate}

\paragraph{}
Die Übertragung ist Bit-seriell, das heißt, die Bits werden hintereinander in einer Datenleitung verschickt. Eine bestimmte Menge an Bits entspricht einem Zeichen. Ein Zeichen besteht aus einem Startbit, aus vier bis acht Datenbits (Nutzdaten), aus ein oder zwei Stopbits und der Parität. Die Parität ist in dem Standard nicht definiert, aber wird benutzt um Fehler zu erkennen und zu beheben. Im Allgemeinen ist die Parität nebensächlich, da sie aber in diesem Fall der Arbeit relevant ist wird sie im späteren Verlauf des Kapitels näher erklärt.


\subsection{Übertragung}
\paragraph{}
Das Startbit meldet dem Empfänger das die Übertragung anfängt. Die Start- und Stopbits haben inversen Pegeln. Ist eine Leitung im Ruhezustand oder hat die Stopbits erhalten, wird durch die Ankunft einer inversen Signalflanke der Empfänger aufmerksam gemacht, dass Nutzdaten ankommen werden. Bei der Ankunft eines Startbits tastet der Empfänger die Nutzdaten mit seiner Bitrate (Bits pro Sekunde) ab. Die Nutzdaten sind die Bitdarstellung von einem ASCII Zeichnen. Die Länge der Daten sind einstellbar, dabei kann die Übertragung von vier bis acht Bits pro Zeichen eingestellt werden. Im Anschluss kommt mindestens ein Stopbit, es können auch 1,5 Bits oder zwei Bits eingestellt werden. 1,5 Bits sind sehr ungewöhnlich, aber damit ist gemeint, dass die Mindestdauer der Pause zwischen zwei ankommenden Zeichen 1,5 Bitzeichen entspricht. 

\paragraph{}
Im Folgenden wird die Übertragung von einem Zeichen näher erläutert:
Wird ein Zeichen 'z' übertragen, mit einem Startbit, acht Datenbits und zwei Stopbits, ist die Gesamtlänge der Übertragung elf Bits lang. 'z' entspricht laut ASCII Kodierung den Wert 122 dezimal und "`7A"' hexadezimal(0x7A). Die Bitdarstellung für 0x7 lautet "`0111"' und für 0xA "`1010"', zusammengesetzt ergibt sich für 0x7A = "`01111010"'. Die Übertragung in diesem Standard folgt dem LSB(Less significant Bit) zuerst, also werden die Bits vertauscht, demnach ergibt sich "`0101 1110"'. Davor wird eine Null hinzugefügt als Startbit und am Ende zwei Einsen als Stopbits. Demnach ergibt sich für die Übertragung des Zeichen 'z' folgenden Bitreihenfolge "`0 0101 1110 11"', die versendet wird.

\paragraph{}
Die Datenübertragung unter RS-232 ist asynchron, das bedeutet es existiert kein gemeinsamer Takt. Die Bitraten zwischen Sender und Empfänger dürfen um wenige Prozent von einander abweichen, sonst wird der Empfänger das Wort zu schnell / langsam abtasten und falsch interpretieren. Dagegen muss die Baudrate bei Sender und Empfänger genau gleich sein. Beide Begriffe sind nicht zu verwechseln. Eine Bitrate definiert die übertragenen Bits pro Sekunde und die Baudrate die übertragenen Symbole pro Sekunde, wo jedes Symbol als definierte messbare Signaländerung im physischen Übertragungsmedium definiert ist. Da die Übertragung im diesem Standard binär ist, ist ein Symbol als ein Bit definiert. Dies hat zu Folge, dass im diesem Spezialfall der Übertragung die Bitrate und die Baudrate gleich sind. Bei anderen Übertragungsarten unterscheiden sie sich jedoch.

\paragraph{}
Die Baudrate ist vom Benutzer frei wählbar. Jedoch hat der Anwender die Kabellänge, den Leitungswiderstand und die Kapazität des Kabels zu beachtet. Je länger das Kabel, desto starker nimmt die Spannung ab. Nach Erfahrungswerten von Texas Instruments ist bei einer Baudrate von 9600, eine maximale Kabellänge von 152 Meter möglich. Bei 115200 muss das Kabel kürzer als 2 Meter sein.\\

%\paragraph{}
Der Empfänger muss die Datenübertragung anhalten können, wenn er keine Daten mehr verarbeiten kann. Dieser Handshake wird softwaretechnisch oder über die Hardware mit Steuerleitungen realisiert. Bei der Softwarelösung werden am Sender spezielle Steuerzeichen gesendet. Dieses Protokoll ist als "`Xon/Xoff"' bekannt. Es ist nur möglich dieses Protokoll zu benutzen wenn die Steuerzeichen(Xon = 0x11 und Xoff = 0x13) nicht in den Nutzdaten vorkommen. Bei der Hardwarelösung signalisieren Sender und Empfänger sich gegenseitig ihren Status. Solche Protokoll besteht zum Beispiel aus fünf Steuerleitungen(TxD, RxD, GND, RTS und CTS). Damit triviale Fehler vermieden werden, müssen Sender und Empfänger die gleichen Einstellungen haben. Das heißt dass die Baudrate, Stopbits, Parität, Handshake und Kabellänge übereinstimmen müssen.


%#######################################################################################
\subsection{UART}
\paragraph{}
Universal Asynchronous Receiver Transmitter(UART) ist eine elektronische Schaltung zur Realisierung von digitalen seriellen Schnittstellen(für diese Arbeit der sogenannte COM Port). Der UART ist zum Senden und Empfangen von Daten über eine Datenleitung vorgesehen. Im industriellen Bereich ist der UART unter dem RS-232 Standard sehr verbreitet. Auch bei Wincor Nixdorf wird diese Schnittstelle zum steuern der COM Ports benutzt.

%#######################################################################################
\subsection{Paritätsbit}
\paragraph{}
Wie schon erwähnt, ist die Parität nicht im RS-232 Standard definiert, aber sie ist für diese Arbeit relevant. Das Paritätsbit dient zur Erkennung fehlerhafte Übertragungen. Die Parität kann gerade(even) oder ungerade(odd) sein und wird durch die Anzahl an Einsen in einer Bitfolge bestimmt. Ist eine gerade Parität festgelegt, wird bei einer gerade Anzahl an Einsen eine Null angehängt, bei ungerade Anzahl eine Eins. Genau das Gegenteil geschieht bei  ungerader Parität. Nach unserem Beispiel mit 0x7A wird bei gerader Parität eine Eins ("`0 0101 1110 \textbf{1} 11"') angehängt.

%#######################################################################################
\subsection{Leitungen und Stecker}
\paragraph{}
Am Anfang wurde der 25-polige D-Sub-Stecker verwendet. Viele dieser 25 Leitungen sind reine Drucker und Terminal-Steuerleitungen aus der elektromechanischen Zeit, somit sind sie für die modernere Peripherie überflüssig. So hat sich der 9-polige D-Sub-Stecker(COM Port) etabliert. Dieser Stecker war nicht ursprünglich für diesen Standard gedacht, sondern wurde von IBM als Notlösung in einem anderen Standard entwickelt, um Platz zu sparen. Der Stecker ist daher unter EIA/TIA-574 zu finden. Für die EIA-232-Datenübertragung werden selten andere Stecker benutzt.
\\
Der 9-polige D-Sub-Stecker besteht aus folgenden Leitungen:\\
\begin{tabular}{llll}
\\
TxD, TX, TD &: Transmit Data, Leitung für ausgehende Daten \\
RxD, RX, RD &: Recieve Data, Leitung für ankommende Daten \\
RTS &: Request To Send, Sendanforderung \\
CTS &: Clear To Send, Sendeerlaubnis \\
DSR &: Data Set Ready, Einsatzbereitschaft \\
GND &: Ground, Signalmasse \\
DCD, CD, RLSD &: Data Carrier Detect, Erkennung einlaufende Daten \\
DTR &: Data Terminal Ready, Datenendeinrichtung ist bereit \\
RI &: Ring Indicator, Datenverbindungsaufbau \\\\
\end{tabular}


EIA-232 ist eine Spannungsschnittstelle, also werden die logische Null und Eins durch positive oder negative Spannungen vertreten. Die Datenleitungen (TxD und RxD) benutzt eine negative Logik. Spannungen zwischen -3V und -15V repräsentieren eine logische Eins. Signale zwischen -3V und +3V gelten als nicht definierte Signale. Die logische Null wird als eine Spannung zwischen +3V und +15V interpretiert.
\\\\
Beim Empfänger, wird ein Signal zwischen +3V und +15V auf den Steuerleitungen als aktiv betrachtet, und inaktiv zwischen -3V und -15V. Beim Sender üblicherweise ±12V.
\\\\
Um Sender und Empfänger zu verbinden, gibt es verschiedene Kabelvarianten, abhängig vom Sender und vom Empfänger. Verbindet man ein Rechner (in der Regel mit einem Stecker) zu einem Modem (mit einer Buchse) ist ein 1:1 Kabel nötig. Sind zwei Rechner mit einander Verbunden, so ist die Rede von einem Nullmodemkabel, bei dem die Leitungen gekreuzt sind. Durch ein Loopback-Stecker bzw. Kurzschlussstecker wird die Sendeleitung direkt and die Empfangsleitung der gleichen Schnittstelle umgeleitet. So ein Stecker wird für die Entwicklung und deren Tests von Kommunikationsanwendungen und Hardware (UART) benutzt.


%#######################################################################################
\subsection{Verwendung der RS-232 Schnittstelle bei Wincor Nixdorf}
\paragraph{}
Die aktuellen BEETLE Systeme haben ein integrierten UART im Chipsatz. Diese COM Ports werden "`Onboard Ports"' genannt und sind "`Legacy Devices"'. Je nach System sind zwei bis sechs COM Ports eingebaut. Wenn ein Kunde weitere Schnittstellen benötigt, kann er diese über den PCI Bus die Anzahl an Ports erweitern. Diese Erweiterung findet durch eine Sunix PCI Karte mit vier oder acht COM Ports statt. Der Kunde kann auch zwei Sunix PCI Karten einbauen.
\\\\
Eine andere Erweiterungsmöglichkeit sind "`ITE"' COM Ports. Diese Ports sind direkt am PCI Bus angeschlossen und im Mainboard eingebaut. Die ITE COM Ports wurden eingebaut, weil der Super I/O in älteren Mainboards nur zwei Legacy COM Ports verwalten konnten. Um mehrere „On Board“ Ports dem Benutzer zur Verfügung zu stellen wurde der ITE Chip eingebaut. Modernere Mainboards sind in der Lage mehr als zwei COM Ports zu verwalten, und deswegen gibt es jetzt bis zu sechs Legacy Ports plus Erweiterungsmöglichkeiten.
\\\\
Die vorgestellten Schnittstellen sind für das Test Tools relevant. Es gibt noch ein anderen COM Port, der nicht in allen BEETLE Systemen vorhanden ist. Einige BEETLE Systeme haben ein iAMT (Intel Active Managment Technologie)\footnote{http://software.intel.com/en-us/articles/using-intel-amt-serial-over-lan-to-the-fullest; 30.08.2013} Chip. Dieser Port ist ein virtueller Port. Durch ein Treiber (SOL, Serial Over LAN) wird der Datenverkehr von der seriellen Schnittstelle auf das LAN umgeleitet. Da es ein virtueller Port ist, wird es nicht möglich sein, diesen Port zu testen. Die genauere Verwendung von iAMT und SOL ist für diese Arbeit nicht relevant, für mehrere Informationen wenden Sie sich an die angegebene Quelle.
\\\\
Die BEETLE Systeme benutzen die COM Ports für verschiedene Zwecke. Für die Kassensysteme, werden an den COM Ports die Scanner und Kundenanzeigen angeschlossen. So kann das BEETLE System die beiden Peripheriegeräte mit Strom versorgen und Daten senden und empfangen. Es werden auch noch Drucker an die COM Ports angeschlossen. Bei ältere BEETLE Systeme wurden die Touchkomponenten für Bildschirme an die RS-232 Schnittstelle angeschlossen. Der Bildschirm war an eine Videoschnittstelle angeschlossen und die Touchsignale wurden über ein COM Port empfangen. Im Banking Bereich werden viele verschiedene Peripheriegeräte pro System über die RS-232 Schnittstelle gesteuert und mit Strom versorgt.



%****************************************************************************************
\newpage
%****************************************************************************************





\section{Microsoft Windows API}

Die Quellen des folgenden Kapitel sind aus "`Programming Windows, Charles Petzold, 1995, 5. Auflage"' und "`Visual C++ 2010, Dirk Louis, 2010"'.

%#######################################################################################
\subsection{Definition}

\paragraph{}
Die Microsoft Windows API "`Application Programming Interface"'(Schnittstelle zur Anwendungsprogrammierung) ist ein Programmteil, dass vom Windows Betriebssystem den Benutzern und vor allem Entwicklern angeboten wird, um Programme an das Betriebssystem anbinden zu können. Ein Betriebssystem (Microsoft Windows, Mac OS, Linux, etc.) ist für Entwickler und Programmierer durch die API definiert. Somit kann eine Applikation über die API alle Funktionsaufrufe ausführen, die ein Betriebssystem anbietet. Nicht nur Funktionen sind in einer API definiert, sondern bestimmte Datenstrukturen und Datentypen durch das Kommando \textit{typedef} wie \textit{LRESULT} oder \textit{CALLBACK}.
\\\\
Mit fast jedem neuen Microsoft Betriebssystem wird die Windows API erweitert und abgeändert. Die erste API, bekannt als \textit{Win16}, für die 16-Bit Versionen von Microsoft Windows. Für Windows 1.0 hatte die API etwa 450 Funktionsaufrufe. Bei der Zeit von Windows 98 wurde die API auf 32-Bit und mehrere tausende Funktionsaufrufe. Ab Windows XP "`x64 Edition"' und Windows Server 2003 wurde die API auch auf 64-Bit erweitert.
\\\\
Der hauptsächlichen Unterschiede zwischen den 16, 32 und 64 Bit Versionen von der API entstanden durch die verschiedenen Speicher und Prozessorarchitekturen. Unter der 16-Bit Architektur war die Registergröße 16 Bit groß, diese wurde bei den Prozessoren von Intel 8086 und 8088 eingesetzt. In der 32-Bit Architektur, 32 Bit groß bzw. in der 64-Bit, 62 Bit groß. Die Windows API ist in der Programmiersprache "`C"' geschrieben. Deswegen war unter der 16-Bit Architektur der Datentyp \textit{int} "`nur"' 16 Bit lang(Zahlen von -32.768 bis 32.767) . In der Speicherverwaltung bestanden Speicheradressen aus einen 16-Bit Segment und einen 16-Bit Offset, der als Zeiger verwendet werden konnte. Für Programmierer war diese Verwaltung sehr Umständlich, da der Programmierer genaue Unterscheiden musste, zwischen \textit{long} oder \textit{far} und \textit{short} oder \textit{near} Zeiger. 
\\\\
Ab der 32-Bit Architektur entstand das "`Flat Memory Model"', wo der Prozessor direkt die gesamte Speicheradressen ansprechen konnte, ohne Speichersegmentierung oder Pagingschemas. Somit wurde auch der \textit{int} Datentyp auf 32 Bitgröße (Zahlen von -2.147.483.649 bis 2.147.483.647) definiert. Programme, die auf einem System mit einer 32-Bit Architektur geschrieben worden sind, benutzen einfache Zeigerwerte um direkt die Speicheradresse ansprechen zu können. Bei der Umstellung von 16-Bit auf 32-Bit blieben viele Funktionsaufrufe gleich, aber manche brauchten eine Umstellung auf 32-Bit, wie zum Beispiel das graphische Koordinatensystem für die GUI Darstellungen.
\\\\
Aus Kompatibilitätsgründe sind die API's Rückwärts kompatibel. Die Kompatibilität entsteht durch eine Übersetzungsschicht. Es gibt zwei Wege der Übersetzung. Im ersten Weg, werden 16-Bit Funktionsaufrufe durch eine Übersetzungsschicht in 32-Bit Funktionsaufrufe umgewandelt und dann vom Betriebssystem bearbeitet. Der andere Weg führt genau in die andere Richtung. Die 32-Bit Funktionsaufrufe werden durch die Übersetzungsschicht übersetzt und wandelt diese in 16-Bit Funktionsaufrufe um, und werden dann vom Betriebssystem bearbeitet.
\\\\
Die Benutzung der API ist nicht die einzige Möglichkeit, Anwendung für die Windowsbetriebssysteme zu programmieren, aber durch die Benutzung der API ist eine bessere Effizienz gewährleistet. Die Anwendungen können auch in Visual Basic oder Borland Delphi geschrieben werden, wo die objektorientierten Grundlagen von Pascal dem Programmierer viel Arbeit abnehmen. Durch Verschachtelungen mehrerer Programmierschichten, die im Endeffekt auf die  API zugreifen, verlangsamen das Programm und im späteren Verlauf der Leistungsoptimierung des Programmes wird der Programmierer früher oder später mit der Komplexität der API konfrontiert.

%----------------------------------------------------------------------------------------------
\subsubsection{API gegenüber .NET Framework}
\paragraph{}
Microsoft hat dieses Framework speziell für die Windows-Plattformen entwickelt. Es ist eine Virtuelle Maschine mit einer Laufzeitumgebung für Microsoft Windows Anwendungen. Dieses Framework ähnelt in vielen Teilen der Java Virtual Machine. Das .NET Framework besteht aus eine Laufzeitumgebung und der .NET Framework-Bibliothek. Aus Sicht des Anwenders hat sich nichts geändert, aber für die Programmierer vieles. Das .NET Framework ist auf C++ und C\# basierend und im Gegensatz zur API, objektorientiert. Die Framework-Bibliothek besteht aus verschiedenen Klassenbibliotheken, wie zum Beipiel die Windows Forms, Windows Presentation Foundations (GUI), Webdienste,... . Ein großer Vorteil ist die Portierung der Programme, dafür muss aber das .NET Framework installiert sein. Das ist für dieses Projekt essentiell, denn es soll auf Schreibgeschütze Medien ausführbar sein (Win PE) und aus diesem Grund wird es von mir nicht verwendet.




%#######################################################################################
\subsection{Windows.h}
\paragraph{}
Die Window.h Headerdatei ist die Masterdatei, die alle anderen Headerdateien inkludiert. In diesen Dateien sind die Funktionsaufrufe, Konstanten, Typdefinitionen und Datenstrukturen für das Windowsbetriebssystem definiert. Diese Headerdateien sind Teil der Dokumentation der API. Im Folgenden sind ein Paar Headerdateien aufgeführt die in der Windwos.h inkludiert werden:

\begin{tabular}{llll}
\textbullet & WINBASE.H & Kernenfunktionen\\
\textbullet & WINDEF.H  & Typdefinitionen\\
\textbullet & WINNT.H  & Typdefinitionen mit Unicode Unterstützung\\
\textbullet & WINUSER.H  & Funktionen für die Benutzerschnittstelle\\
\textbullet & WINGDI.H  & Graphische Schnittstelle\\
\end{tabular}

%#######################################################################################
\subsection{WinMain}
\paragraph{}
\textit{C/C++} Programme fangen mit eine \textit{int main()} Funktion an. Da die API auf \textit{C} basiert, fangen Anwendungen mit Windows als Zielsystem mit einer ähnliche Funktion an. Unter Windows ist die \textit{main} Funktion unter "`WINBASE.H"' als:

\begin{tabbing}

int WINAPI \=WinMain(\\
    			\>HINSTANCE hInstance,\\
    			\>HINSTANCE hPrevInstance,\\
    			\>LPSTR lpCmdLine,\\
    			\>int nShowCmd\\
			\>);
\\
\end{tabbing}

Der Bezeichner \textit{WINAPI} beschreibt einen Datentyp. Dieser Datentyp ist definiert als \textit{WINAPI \_\_stdcall}. \textit{\_\_stdcall} ist eine Aufrufkonvention um Funktionen aus der Win32 API aufzurufen. Die \textit{WinMain} Funktion bekommt als Parameter zwei \textit{HINSTANCE} Variablen, ein \textit{LPSTR} (Zeiger auf eine Zeichenkette) und ein \textit{int}.\\\\


\textit{HINSTANCE} ist ein Handle auf eine Instanz. Das ist die Basisadresse von einem Modul im Systemspeicher(eine 32-Bitzahl, dass auf ein Objekt zeigt). Der erste Parameter ist eine Instanz auf die aktuelle Anwendung. Der zweiter Parameter wurde nur unter Win16 benutzt und ist in der Win32 API irrelevant, er wird automatisch auf \textit{NULL} gesetzt. Der dritte Parameter enthält die Befehlszeilenargumente als Zeichenfolge. Aus dieser Zeichenfolge wertet das Programm aus, wie es ausgeführt werden soll. Der vierte und letzte Parameter ist ein Flag und gibt an, wie das Anwendungsfenster angezeigt werden soll (Minimiert, Maximiert oder Normalgröße).

%#######################################################################################
\subsection{Graphic User Interface (GUI)}
\paragraph{}
Durch die Begrenzung der einzubauenden Hardware in den frühen Jahren des Computerzeitalters (Speicher und Prozessoren) waren alle Betriebssysteme Kommandozeileorientiert. Dies sollte sich aber ändern durch die Recherche von Xerox Palo Alto Research Center(PARC). Mitte der 70 Jahren wurde im Xerox PARC nach graphische Benutzeroberflächen recherchiert. Aus diesen Ergebnissen profitierten Macintosh und Windows, und bauten darauf ihre Betriebssysteme mit graphischen Benutzeroberflächen(Mac OS und Windows). Heutzutage kann man sich als Benutzer kaum eine Computerwelt ohne Benutzeroberflächen vorstellen. Die Windows API hat seit der Ankündigung(1983) und Veröffentlichung(1985) von Windows als Betriebssystem Funktionsaufrufe in die Headerdateien für die Programmierung von GUI's. Die Benutzung der API für die Programmierung von GUI's ist vielleicht "altmodisch", aber immerhin sehr genau und präzise. Im Gegensatz zu "`GUI Builders"' wird kein unnötiger, und oft für Programmierer, unverständlicher Code geschrieben. Der Überblick und Verständnis der GUI Elemente wird durch die direkte Benutzung der API vereinfacht. Vor allem wird das Verständnis wie eigentlich eine GUI unter Windows und Windows als Betriebssystem funktioniert, durch die Verwendung der API deutlicher.

%#######################################################################################
\subsection{Aufbau einer GUI}
\paragraph{}
Nachdem die \textit{WinMain} Funktion die nötigen Parameter bekommt und diese vom Programm ausgewertet werden, muss die GUI als solche gebaut und registriert werden. Eine GUI besteht aus drei Teilen.


%----------------------------------------------------------------------------------------------
\subsubsection{Initialisierung und Erzeugung der GUI}
\paragraph{}
Damit der Benutzer ein Programmfenster sehen kann, muss dieses zuerst deklariert und initialisiert werden. Danach wird dieses Fenster dem System bekannt gegeben, in dem es registriert wird. Um ein Fenster zu deklarieren muss eine Variable der Struktur \textit{WNDCLASS} erzeugt werden. Diese Struktur wird in \textit{WINUSER.H} definiert und beinhaltet verschiedene Variablen, die die Eigenschaften des jeweiliges Fenster beschreiben.



\begin{tabular}{llll}
& typedef struct\\
& \{\\
& & UINT        & style ;\\
& & WNDPROC     & lpfnWndProc ;\\
& & int         & cbClsExtra ;\\
& & int         & cbWndExtra ;\\
& & HINSTANCE   & hInstance ;\\
& & HICON       & hIcon ;\\
& & HCURSOR     & hCursor ;\\
& & HBRUSH      & hbrBackground ;\\
& & LPCTSTR     & lpszMenuName ;\\
& & LPCTSTR     & lpszClassName ;\\
&\}WNDCLASS,&* PWNDCLASS ;
\end{tabular}

Die zwei wichtigsten Variablen dieser Struktur ist die Zweite und die Letzte Variable. Die zweite Variable \textit{WNDPROC lpfnWndProc} beschreibt die Fensterprozedur. Genaueres zu dieser Variable wird demnächst erklärt. Die letzte Variable \textit{LPCSTR lpszClassName}, beschreibt die Klasse des Fensters. Die Variable \textit{HINSTANCE hInstance} muss dem Leser bekannt sein. Diese Variable wird auf den Wert gesetzt, welches das Programm über die \textit{WinMain} bekommen hat. Alle andere Variablen der Struktur beschreiben wie das Fenster aussehen soll und sind für das Verständnis weiterhin irrelevant.
\\\\
Nachdem die \textit{WNDCLASS} Struktur deklariert und initialisiert wird, muss diese registriert werden. Durch den Aufruf der Funktion \textit{RegisterClass}, die als Übergabeparameter einen Zeiger auf eine \textit{WNDCLASS} Struktur hat, wird dem System bekannt gegeben, dass ein Fenster aufgebaut werden soll (mit dem gesetzten Eigenschaften der \textit{WNDCLASS} Struktur). Wenn das Registrieren erfolgreich war, muss das Fenster noch erzeugt werden. Das System kennt das Fenster, aber es ist noch nicht sichtbar.\\

Damit ein Fenster sichtbar wird, muss der Programmierer die \textit{CreateWindow}\footnote{http://msdn.microsoft.com/en-us/library/windows/desktop/ms632679(v=vs.85).aspx; 27.08.2013} Funktion aufrufen. 


\begin{tabular}{llll}
&HWND WINAPI CreateWindow (&\\
& & In\_opt & LPCTSTR lpClassName,\\
& & In\_opt & LPCTSTR lpWindowName,\\
& & In      & DWORD dwStyle,\\
& & In      & int x,\\
& & In      & int y,\\
& & In      & int nWidth,\\
& & In      & int nHeight,\\
& & In\_opt & HWND hWndParent,\\
& & In\_opt & HMENU hMenu,\\
& & In\_opt & HINSTANCE hInstance,\\
& & In\_opt & LPVOID lpParam\\
&);
\end{tabular}

Diese Funktion ist sehr wichtig bei der Erzeugung von graphischen Oberflächen, denn man kann alle Arten von Fenstern damit erzeugen. Damit ist gemeint, dass diese Funktion  nicht nur "`Hauptfenster"', sondern auch die einzelnen GUI Elemente erzeugt. Der erste Parameter beschreibt dieses Verhalten. Die \textit{CreateWindow} Funktion erwartet eine null terminierte Zeichenkette. Diese Zeichenkette ist immer eine vordefinierte Systemklasse. Zum Beispiel, um ein Schaltfläche zu erstellen, muss hier als Parameter "`button"' angegeben werden. Wenn der Programmierer ein von ihm erzeugtes Fenster darstellen will, muss er deswegen vorher im System eine Fensterklasse registrieren. Aus diesem Grund muss der Programmierer eine Fensterstruktur \textit{WNDCLASS} registrieren. Um danach ein selbst gebautes Fenster zu erzeugen, muss der Programmieren den registrierten Fensterklassenname(\textit{WNDCLASS lpszClassName}) angeben (anstatt "`button"' oder andere vordefinierte Fensterklassen).\\

Der zweite Parameter beschreibt der dargestellter Name des Fenster. \textit{DWORD dwStyle} ist eine Bitmaske, die die Darstellungsart des Fensters beschreibt. Die Darstellungsarten sind als konstante Werte (Window Styles\footnote{http://msdn.microsoft.com/en-us/library/windows/desktop/ms632600(v=vs.85).aspx; 27.08.2013})in der \textit{WINUSER.H} Headerdatei definiert. Um ein "`traditioneles"' Fenster zu erzeugen muss hier \textit{WS\_OVERLAPPEDWINDOW} angegeben werden. Die Nächste vier Parameter beschreiben die Positionierung im Bildschirm und die Breite und Höhe des Fensters.\\ 


\textit{HWND hWndParent} beschreibt ein Handle auf ein anderes Fenster. Im Falle, dass dieses Fenster das Hauptfenster ist, wird hier NULL übergeben, sonst muss das Handle auf das "`Parent Windows"' zeigen. Das \textit{HMENU hMenu} ist für das Hauptfenster irrelevant. Es ist aber wichtig für Unterfenster(Popup Fenster oder GUI Elemente wie Knöpfe). \textit{HMENU} ist eine Typdefinition für ein Handle auf ein Fenstermenü oder ein Unterfenster. Somit kann das Hauptfenster eine Kommando eines GUI Elements erkennen und auswerten, mehr dazu unter "`Die Message Loop"'. Das \textit{HINSTANCE hInstance} wurde schon vorher erläutert und das letzte Parameter beschreibt extra Information wenn es nötig ist, üblicherweise wird hier NULL angegeben.

\paragraph{}
Die \textit{CreateWindow} Funktion liefert als Rückgawert ein \textit{HWND}. Dies steht für Handle auf ein Fenster. Somit kann der Programmierer und Programm auf ein gewünschtes Fenster zugreiffen. Um die erwähnte Parameter genauer zu verstehen folgende Beispiele. Hat man ein Hauptfenster, so ruft man die \textit{CreateWindow} Funktion folgendermaßen:

\begin{tabular}{llll}
& HWND hwnd\_Fenster = CreateWindow (\\
\\
& szAwendungsName,					& //Fensterklasse vom Programmierer registriert\\                            
& "Das ist eine Hauptfenster",  	& //Text auf der Titelleiste\\                                
& WS\_OVERLAPPEDWINDOW,              & //Stil des Fensters\\                         
& CW\_USEDEFAULT,                    & //Position in der X Koordinate des Bildschirmes\\     
& CW\_USEDEFAULT,                    & //Position in der Y Koordinate des Bildschirmes\\     
& CW\_USEDEFAULT,                    & //Lange des Fensters\\                                  
& CW\_USEDEFAULT,                    & //Breite des Fensters\\                                 
& NULL,                              & //Kein zugehöriges Hauptfenster\\                           
& NULL,                              & //Keine Identifikationsnummer\\                               
& hInstance,                         & //Programminstanz\\                                 
& NULL                               & //keine extra Information\\  
& );                          
\end{tabular}                        

\paragraph{}
Will der Programmierer ein GUI Element (wie zum Beispiel ein Schaltfläche) im Hauptfenster darstellen, muss die Funktion mit diesen Parametern aufgerufen werden:
\\
\\
\begin{tabular}{llll}
& HWND Schaltfläche = CreateWindow (\\
\\
& "button",					& //Fensterklasse Schaltfläche\\
& "Das ist eine Schaltfläche",		& //Text auf den Schaltfläche\\
& WS\_CHILD | WS\_VISIBLE,	& //Child Fenster und anzeigen\\
& 100,						& //Position in der X Koordinate des Hauptfensters\\
& 100,						& //Position in der Y Koordinate des Hauptfensters\\
& 50,						& //Lange des Schaltfläche\\
& 35,						& //Breite des Schaltfläche\\
& hwnd\_Fenster,				& //Zugehöriges Hauptfenster\\
& (HMENU) ID\_Schaltfläche,			& //Identifikationsnummer, wird vorher deklariert\\
& NULL,						& //keine Instanz\\
& NULL						& //keine extra Information\\
& );
\end{tabular}

\paragraph{}	
					
Nachdem der Programmierer ein Hauptfenster erzeugt hat, muss dieses noch explizit mittels der Funktionen \textit{ShowWindow(hwnd\_Fenster, iCmdShow)} und \textit{UpdateWindow(hwnd\_Fenster)}	angezeigt werden.

%----------------------------------------------------------------------------------------------				
\subsubsection{Die Message Loop}
\paragraph{}
Windows hat eine Nachrichten Schleife (message loop) für jede laufende Anwendung. Wenn der Benutzer ein Event auslöst(Mausklick oder Tastatureingabe) muss das Programm reagieren. Windows übersetzt das Event in eine Nachricht und diese Nachricht wird in die Schleife reingeschrieben. Wenn eine neue Nachrichten empfangen wird, bevor die aktuelle Nachricht fertig bearbeitet wurde, wird die ankommende Nachricht in die "`Message Queue"'(Warteschlange) geschrieben. Jede Nachricht ist durch die \textit{MSG} Struktur beschrieben.

\begin{tabular}{llll}
& typedef & struct tagMSG\\
& \{\\
&  & HWND   & hwnd ;\\
&  & UINT   & message ;\\
&  & WPARAM & wParam ;\\
&  & LPARAM & lParam ;\\
&  & DWORD  & time ;\\
&  & POINT  & pt ;\\
& \}\\
& MSG,&* PMSG;\\
\end{tabular}

\paragraph{}
Jede Nachricht hat als erster Parameter ein Handle auf das zugehörige Fenster. Danach als \textit{unsigned int (UINT)} wird die Nachricht übergeben. Diese Nachrichten sind in \textit{WINUSER.H} deklariert und habe den Präfix \textit{WM} für "`Window Message"'. Zum Beispiel wird ein Mausklick in das Fenster gemacht, schickt Windows eine Nachricht an das Fenster(durch \textit{hwnd} angegeben) mit der Nachricht \textit{WM\_RBUTTONDOWN}.

\paragraph{}
\textit{wParam} und \textit{lParam} sind 32-Bit Nachrichtenparametern, abhängig vor der jeweiligen Nachricht. Wird zum Beispiel auf eine Schaltfläche gedrückt, wird die \textit{WM\_COMMAND} Nachricht verschickt. Damit die Anwendung genau erkennen was für eine Aktion ausgeführt worden ist, wird in \textit{wParam} noch zwei weitere Angaben mitgeschickt. In die oberen 16-Bits wird die Notifikation \textit{BN\_CLICKED} verschickt. Dies deutet an, dass ein Schaltfläche geklickt worden ist. In den unteren 16-Bits von \textit{wParam} wird die Identifikationsnummer(nach den obigen Beispiel: ID\_Schaltfläche) der Schaltfläche mitgeschickt. Mit diesen Informationen kann ein Programm genau auf die vom Benutzer ausgelöste Events reagieren. Beider 16-Bit Werte werden mit Hilfe der Makros \textit{HIWORD} \footnote{http://msdn.microsoft.com/en-us/library/windows/desktop/ms632657(v=vs.85).aspx; 27.08.2013} und \textit{LOWORD} \footnote{http://msdn.microsoft.com/en-us/library/windows/desktop/ms632659(v=vs.85).aspx; 27.08.2013}.

\paragraph{}
Der Parameter \textit{time} gibt die Uhrzeit wann die Nachricht verschickt worden ist und der Parameter \textit{pt} ist eine \textit{POINT} Struktur, wo die X und Y Koordinaten des Mausklicks gespeichert sind.

\paragraph{}
Eine Nachrichten Schleife ist standardmäßig so aufgebaut:

\begin{tabular}{llll}
while & (GetMessage (\&msg, NULL, 0, 0))\\
\{\\
     & TranslateMessage (\&msg) ;\\
     & DispatchMessage (\&msg) ;\\
\}\\
\end{tabular}

\paragraph{}
Die \textit{GetMessage} Funktion speichert in der \textit{msg} Struktur die aktuelle Nachricht. Die drei andere Parameter spezifizieren, dass alle Nachrichten(von der jeweilige Anwendung) in die Schleife geschrieben werden. Die Funktion liefert immer ein Wert ungleich Null, außer wenn die Nachricht \textit{WM\_QUIT} lautet, denn damit wird die Schleife verlassen und das Programm beendet.

\paragraph{}
\textit{TranslateMessage} gibt die Nachricht an das Betriebssystem weiter und übersetzt die virtuelle Tasten Nachrichten auf tatsächliche Charakteren. Die \textit{DispachtMessage} Funktion gibt die an Windows weiter. Gemeint ist, dass Windows die richtige Fensterprozedur (\textit{WndProc} wird später erklärt)aufruft. Wenn die Fensterprozedur die Nachricht bearbeitet hat, gibt die Nachricht wieder an Windows. Windows gibt die bearbeitete Nachricht weiter an die jeweilige Anwendung und so kann die Schleife die nächste Nachricht laden und bearbeiten.



%----------------------------------------------------------------------------------------------
\subsubsection{Fensterprozedur: WndProc Funktion}
\paragraph{}
Unter der Initialisierung und Erzeugung der GUI wurde die Fensterprozedur schon einmal erwähnt. In dieser Variable ist der Name der Funktion, die die Nachrichten eines Fensters bearbeitet. Das heißt, wird eine Fensterstruktur als \textit{WNDCLASS wc} deklariert, und der Parameter \textit{WNDPROC lpfnWndProc} folgendermaßen initialisiert \textit{wc.lpfnWndProc = WndProc;} muss die Fensterprozedur für dieses Fenster \textit{WndProc} heißen. Wie die Fensterprozedur heißt ist irrelevant, solange die Namen in der Fensterklasse und die Prozedur übereinstimmen, somit sind Fenster und Prozedur verbunden. Eine Fensterprozedur ist immer so definiert:

\begin{tabular}{ll}
LRESULT CALLBACK & WndProc(\\
& HWND hwnd,\\
& UINT message,\\
& WPARAM wParam,\\
& LPARAM lParam);
\end{tabular}



\paragraph{}
Der Datentyp \textit{CALLBACK} ist schon bekannt, und \textit{LRESULT} ist eine Typdefinition von \textit{long}. Die vier Parameter der Funktion sind die gleichen wie die ersten vier Parameter bei eine \textit{MSG} Struktur. Falls ein Programm mehrere Fenster von der gleichen Fensterklasse hat, spezifiziert das erste Parameter welches Fenster(Handle) die Nachricht schickt. Programme rufen die Fensterprozedur in der Regel nicht auf, sondern Windows. Will ein Programm die Prozedur direkt aufrufen, dann wird die Funktion \textit{SendMessage}(wird später genauer erklärt) benutzt. 

\paragraph{}
Der Sinn für eine von Programmierer geschriebene Fensterprozedur ist, dass ein Programm auf ein Event reagiert soll, wie der Programmierer es will. Programmierer programmieren in der Regel nicht alle Events. Damit eine Nachricht nicht unbearbeitet bleibt, wird immer am Ende der selbstgeschriebene Fensterprozedur die \textit{DefWindowProc} Funktion aufgerufen. Diese Methode bearbeitet alle mögliche Nachrichten und ist die default Fensterprozedur. Wenn der Programmierer diese Funktion nicht aufruft, werden grundlegende Funktionen einer GUI nicht funktionieren.

\paragraph{}
Die erste Nachricht die eine Fensterprozedur bekommt ist \textit{WM\_CREATE} Nachricht. Hier baut der Programmierer alle GUI Elemente auf, mithilfe der \textit{CreateWindow} Funktion(Schaltfläche Beispiel). Eine zweite sehr wichtige Nachricht ist \textit{WM\_DESTROY}. Die Nachricht wird verschickt wenn der Benutzer ein Fenster zu machen will. Der Programmierer ruft die \textit{PostQuitMessage(0)} Funktion auf und automatisch wird eine \textit{WM\_QUIT} Nachricht verschickt. Somit wird das Fenster geschlossen, die Message Loop verlassen und das Programm / Fenster richtig beendet.

\paragraph{}
Es gibt noch weitere Nachrichten, die der Programmierer "`manuell"' verschicken kann. Mit Hilfe der erwähnte \textit{SendMessage} \footnote{http://msdn.microsoft.com/en-us/library/windows/desktop/ms644950(v=vs.85).aspx; 28.08.2013} Funktion. Die Funktion hat die gleichen Parameter wie eine Fensterprozedur. Durch das Handle wird angegeben an welches Fenster die Nachricht verschickt werden soll. Durch das zweite Parameter wird angegeben, welche Nachricht verschickt wird, und die letzten zwei sind extra Informationen der Nachricht(wenn nötig). Will der Programmierer im Ablauf des Programms zum Beispiel der Darstellungstext von unseren Schaltfläche ändern, wird die \textit{SendMessage} Funktion so aufgerufen:

\begin{center}
SendMessage(hwnd\_Schaltfläche, WM\_SETTEXT, 0, (lParam)"NeuerText");
\end{center}

%----------------------------------------------------------------------------------------------
\subsection{Die RS-232 Schnittstelle und die Windows API}\label{COMWINAPI}
\paragraph{}
Über die Windows API hat man direkt Zugriff auf die RS-232 Schnittstelle. Zum verwalten der Schnittstelle und die Eigenschaften zu setzen gibt es verschiedene Datenstrukturen die man aufrufen und ändern muss, je nach Bedarf.


%----------------------------------------------------------------------------------------------
\subsubsection{Öffnen und Schließen eines Ports}
\paragraph{}
Um Zugriff auf die Datenstrukturen zu haben, muss man zuerst eine RS-232 Schnittstelle (COM Port) öffnen. Durch die Funktion CreateFile\footnote{http://msdn.microsoft.com/en-us/library/windows/desktop/aa363858(v=vs.85).aspx; 25.08.2013} bekommt man ein Handle auf den angegeben Port. Ein Handle ist eine Referenzwert zu einer vom Betriebssystem verwalteten Systemressource, im diesem Fall eine im System vorhandene RS-232 Schnittstelle. Mit \textit{CreateFile} kann man auch Zugriff auf Dateien, Datenstreams und andere Kommunikationsressourcen bekommen. Das Handle muss gespeichert werden, denn damit wird der jeweiliger Port identifiziert und angesprochen für weitere Operationen. Durch die \textit{CreateFile} Funktion wird die Datei, oder im diesem Fall die Input / Output Schnittstelle für diese Anwendung reserviert. Das heißt, für das Betriebssystem und andere Anwendungen steht diese Schnittstelle nicht mehr zur Verfügung.

\paragraph{}
Um den richtigen Zugriff auf einen Port zu haben, muss auch die richtige Flags bei dem Aufruf der \textit{CreateFile} Funktion angegeben werden. Als Flags sind die folgende Parameter anzugeben:
\begin{itemize}
\item Schreib und Leserechte
\item Non-Sharing Modus
\item Öffnen vor nur existierende Schnittstellen
\item Asynchron Modus
\end{itemize}


\paragraph{}
Um ein Programm "`sauber"' zu beenden müssen offene Handles geschlossen werden. Durch die Funktion \textit{CloseHandle}\footnote{http://msdn.microsoft.com/en-us/library/windows/desktop/ms724211(v=vs.85).aspx; 25.08.2013} mit Angabe eines gültiges Handles wird dieses geschlossen, und steht für das Betriebssystem und andere Anwendungen wieder zur Verfügung.


%----------------------------------------------------------------------------------------------
\subsubsection{Konfiguration eines Ports}
\paragraph{}
Es gibt drei wichtige Strukturen, die für die Konfiguration einer COM Schnittstelle relevant sind. Mittels dieser Strukturen werden die Eigenschaften, einstellbare Parameter und Wartezeiten einer Schnittstelle eingestellt.

\paragraph{}
Die \textit{DCB}\footnote{http://msdn.microsoft.com/en-us/library/windows/desktop/aa363214(v=vs.85).aspx; 28.08.2013} Struktur definiert die Ansteuerungseigenschaften für die Schnittstelle. Um die Struktur für eine angegebene Schnittstelle zu laden, wird die Funktion \textit{GetCommState} aufgerufen. Diese Struktur besteht aus 28 verschiedene Variablen die ich nicht einzeln benennen werde. Diese Variablen beschreiben wie die Schnittstelle konfiguriert ist. Man kann die Baudrate, Parität, Stopbits, Datenbits, Flusssteuerung und Fehlerbenachrichtigung einstellen.

\paragraph{}
Um die Schnittstelle richtig einzustellen und keine falsche Eingaben in die \textit{DCB} Struktur zu schreiben, ist es sinnvoll vorher die \textit{COMMPROP} \footnote{http://msdn.microsoft.com/en-us/library/windows/desktop/aa363189(v=vs.85).aspx; 28.08.2013} Struktur zu auswerten. Durch die Funktion \textit{GetCommProperties} wird die Struktur für die angegebene Schnittstelle geladen. Diese Struktur besteht aus 18 Variablen und beschreibt die mögliche Einstellung für die Schnittstelle. Die Einstellungen werden aus dem Treiber der jeweiliger Schnittstelle(Onboard Ports, Sunix, Intel SOL oder ITE) gelesen. Die für diese Arbeit relevanter Parameter ist die maximale einstellbare Baudrate.
%wSettableStopParity
%dwSettableParams


\paragraph{}
Während der Übertragung von Daten über eine Serielleschnittstelle sind maximale Wartezeiten fällig. Dieses Werte entstehen durch die Übertragungslänge und die eingestellte Baudrate. Auch die Wartezeit zwischen zwei ankommende Bytes ist wichtig um das Ende der Übertragung zu bestimmen. Diese Werte sollten dynamisch berechnet werden und danach in die Schnittstelle eingestellt werden. Dafür ist die \textit{COMMTIMEOUTS} \footnote{http://msdn.microsoft.com/en-us/library/windows/desktop/aa363190(v=vs.85).aspx; 28.08.2013} Struktur zuständig. Die Struktur besteht aus fünf Variablen die die Wartezeiten in Millisekunden angeben. Die erste Variable beschreibt die Zeitüberschreitung zwischen zwei ankommende Bytes, wird dieser Wert überschritten, so wird die Leseoperation beendet.

\paragraph{}
Der zweite und vierte Parameter(jeweils für Lesen und Schreiben) beschreiben die Zeit, die für die Übertragung aller Bytes nötig ist(für die aktuelle Schreibe- oder Leseoperation). Diese Parametern sind von der Baudrate und die Bitlänge eines Charakters. Damit ist gemeint, wie unter 3.1.2 erläutert, ein Charakter kann aus 8 Bits plus Startbit, Stopbit und Parität bestehen. Also werden nicht genau 8 Bits(1 Byte) per Charakter, sondern oft mehr (11 Bits zum Beispiel) übertragen. Die Wartezeit wird durch die folgende Formel berechnet.

\begin{center}
$ Wartezeit = \frac{Anzahl der Bits}{Baudrate} \times 1.1$
\end{center}

\paragraph{}
In der Formel wird mal 1.1 multipliziert um eine 10\% Kulanz zu haben. Der dritte und fünfte Parameter sind eine extra Wartezeit, für jeweils Lesen und Schreiben, die zu der gesamte berechnete Wartezeit pro Lese-/Schreibvorgang addiert wird. Falls der berechnete Wert unter zehn Millisekunden ist, wird dieser auf zehn Millisekunden gesetzt.


\paragraph{}
Wenn ein Port geöffnet wird, muss der Programmierer die Art der Kommunikation angeben. Die Kommunikation zwischen die Schnittstellen kann synchron(nonoverlapped) oder asynchron(overlapped) erfolgen. Für diese Arbeit habe ich mich für asynchrone Kommunikation entschieden. Dieser Art der Kommunikation ist etwa komplexer, bietet aber mehr Flexibilität und Effizienz.



%----------------------------------------------------------------------------------------------
\subsubsection{Lesen und Schreiben}
\paragraph{}
Nach dem ein Port konfiguriert ist, wie es nötig ist, kann man dieses Port benutzen um Informationen zu schicken oder empfangen. Um in einem Port zu schreiben oder aus einem Port zu lesen gibt es jeweils eine Funktion. Um im einem Port zu schreiben wird die Funktion \textit{WriteFile}\footnote{http://msdn.microsoft.com/en-us/library/windows/desktop/aa365747(v=vs.85).aspx; 28.08..2013}. Die Funktion benötigt als erster Parameter das Handle auf das geöffnete Port. Als zweites muss angegeben werden, welche Information geschrieben werden soll und die Größe dieser Information in Bytes. Als optionale Parameter kann man ein Zeiger wo die Menge der geschriebene Bytes geschrieben wird und ein Zeiger zu einer \textit{OVERLAPPED} Struktur. Die Kommunikation zwischen Ports in dieser Arbeit ist Asynchron, deswegen wird hier eine Zeiger auf eine Struktur gegeben.

\paragraph{}
Das Lesen aus einem Port geschieht sehr ähnlich wie das Schreiben.Die Funktion dafür heißt \textit{ReadFile}\footnote{http://msdn.microsoft.com/en-us/library/windows/desktop/aa365467(v=vs.85).aspx; 28.08.2013}. Die Lesefunktion brauch genau die gleichen Parameter wie die Schreibfunktion. Da die Lese und Schreibvorgange sehr ähnlich sind, ist der Aufbau beider Funktionsaufrufe auch ähnlich.

\paragraph{}
Um aus einem Port zu lesen oder schreiben muss zuerst eine \textit{OVERLAPPED} Struktur deklariert werden. Somit sichern wir, dass die Kommunikation asynchron ist. Danach muss in der Struktur der Parameter \textit{hEvent} initialisiert werden. Dieser Parameter ist ein Handle auf ein Event. Ein Event im diesem Fall ist der Schreibe oder Lesevorgang. Durch dieses Event kann der Status von der Vorgang abgefragt werden. Als erstes wird die jeweilige Lese oder Schreibfunktion aufgerufen. Wenn dieser Vorgang erfolgreich war, muss der Status abgefragt werden, um sicher zu sein, dass der Vorgang vollständig ist.
 
\paragraph{}
Im Fall, dass sich das Schreiben oder Lesen noch verzögert, muss auf das beenden des Events gewartet werden. Zuerst muss der Programmierer Abfragen, ob ein Fehler entstanden ist. Wenn der Fehler \textit{ERROR\_IO\_PENDING} muss das Programm noch warten, sonst ist ein anderer Fehler entstanden. Um an das Beenden eines Events zu warten und reagieren, wird die Funktion \textit{WaitForSingleObject}\footnote{http://msdn.microsoft.com/en-us/library/windows/desktop/ms687032(v=vs.85).aspx; 28.08.2013} aufgerufen. Diese Funktion wartet bis das angegebene Event(lesen oder schreiben) sein Status ändert oder eine bestimmte Zeit abläuft. Diese Zeit ist der Timeout was vorher berechnet worden ist.
 
\paragraph{}
Wenn die Zeit abläuft, wir ein Timeout Fehler angegeben. Das heißt, das Programm muss noch warten. Ändert sich der Status des Events, bevor die Zeit abläuft wird mittels der Funktion \textit{GetOverlappedResult}\footnote{http://msdn.microsoft.com/en-us/library/windows/desktop/ms683209(v=vs.85).aspx; 28.08.2013} das Event noch abgefragt. Dieser Funktion müssen das Handle des Ports, sowie die \textit{OVERLAPPED} Struktur und die Anzahl an Bytes die transferiert werden sollten, angeben. Wenn diese Funktion keine Fehler meldet, dann wurde der jeweilige Vorgang erfolgreich abgeschlossen.

\paragraph{}
Im Fall eines Schreibvorgang, muss der Programmierer sicherstellen, dass alle Bytes geschrieben worden sind. Ist es ein Lesevorgang, muss sicher gestellt werden, dass die komplette Information angekommen ist, bevor gelesen wird. Es kann daher zu Timeout Fehler kommen. Um solche Fehler nicht als Abbruchbedingung zu melden, wird nach Vereinbarung mit dem Auftragsteller, fünf mal versucht, fertig zu lesen oder schreiben. Wenn danach der Fehlern noch vorliegt, wird dieser gemeldet.