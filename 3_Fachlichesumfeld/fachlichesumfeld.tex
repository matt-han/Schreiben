\chapter{Fachlichesumfeld}\label{chp:fachlichesumfeld}

\section{RS 232 (Radio Sector 232)}

Die Quellen dieses Kapitel sind aus "`http://de.wikipedia.org/wiki/RS-232; 25.08.2013"' und "`Joe Campbell: V 24 / RS-232 Kommunikation. 4. Auflage. Sybex-Verlag GmbH"'.

\paragraph{}
Der RS 232 ist ein Standard der in den 60er Jahren von die US-amerikanische Standardisierungskomitee Electronic Industries Association(EIA) bearbeitet und definiert wurde. Bei diesem Standard haltet es sich um eine serielle Schnittstelle die für die serielle Kommunikation zwischen Rechnern und Modems in einer Punkt-zu-Punkt Verbindung(über Telefonleitungen) diente.


%#######################################################################################
\subsection{Definition}
\paragraph{}
Unter der RS 232 Standard ist die Verbindung zwischen eine Datenendeinrichtung(DEE, zum Beispiel das Terminal) und eine Datenübertragungseinrichtung(DÜE, zum Beispiel einem Modem) und dessen Parameter definiert. Unter Parameter sind der Spannungspegel, Übertragungsprotokoll(Handshake), Stecker und Timing zu verstehen.

\paragraph{}
Die Übertragung ist Bit-seriell, das heißt, Bits werden hintereinander verschickt in einer Datenleitung. Eine bestimmte Menge an Bits entspricht ein Wort. Ein Wort entsteht aus ein Startbit, die tatsächliche Datenbits(Nutzdaten), ein oder zwei Stopbits und die Parität. Die Parität ist in den Standard nicht definiert, aber wird benutzt um Fehler zu erkennen und beheben. Die Parität wird hier betrachtet, da sie für diese Arbeit relevant ist und wird später genauer erklärt.

\subsection{Übertragung}
\paragraph{}
Der Startbit meldet den Empfänger das die Übertragung anfängt. Start- und Stopbits habe inversen Pegeln. Also ist eine Leitung in Ruhezustand oder hat die Stopbits erhalten, wird durch die Ankunft einer inversen Signalflanke aufmerksam gemacht, dass danach Nutzdaten ankommen werden. Bei der Ankuft eines Startbits tastet der Empfänger die Nutzdaten mit seiner Bitrate(Bits pro Sekunde).  Die Nutzdaten sind die Bitdarstellung von einem ASCII Zeichnen. Die Nutzdaten sind einstellbar, die Übertragung kann jeweils von 4 bis 8 Bits pro Zeichen eingestellt werden. Danach kommt mindestens ein Stopbit. Es können auch 1,5 Bits und zwei Bits eingestellt werden. 1,5 Bits kling sehr ungewöhnlich, aber damit ist gemeint, dass die Mindestdauer der Pause zwischen zwei ankommende Wörter 1,5 Bitzellen entspricht. 

\paragraph{}
Um genauer die Übertragung von einem Zeichen zu verstehen, folgender Beispiel. Wird eine Charackter 'z' übertragen, mit einem Startbit, acht Datenbits und zwei Stopbits, ist die gesamt Länge der Übertragung elf Bits lang. 'z' entspricht laut ASCII Kodierung den Wert 122 dezimal und "`7A"' hexadezimal(0x7A). Die Bitdarstellung für 0x7 lautet "`0111"' und für 0xA "`1010"', zusammen für 0x7A = "`01111010"'. Die Übertragung im diesem Standard folgt mit dem LSB(Less significant Bit) zuerst, also werden die Bits vertauschst zu "`0101 1110"'. Davor wird eine Null zugefügt als Startbit und am Ende zwei Einsen als Stopbits. Das Ergibt, dass für die Übertragung eines 'z' die Bitreihenfolge "`0 0101 1110 11"' verschickt wird.

\paragraph{}
Die Datenübertragung unter RS 232 ist asynchron, das bedeutet es existiert kein gemeinsamer Takt. Die Bitraten zwischen Sender und Empfänger dürfen um wenig Prozent von einander abweichen, sonst wird der Empfänger das Wort zu schnell / langsam abtasten und falsch interpretieren. Dagegen muss die Baudrate bei Sender und Empfänger genau gleich sein. Beide Begriffe sind nicht zu verwechseln. Eine Bitrate definiert die übertragene Bits pro Sekunde und die Baudrate die übertragene Symbole pro Sekunde, wo jedes Symbol als definierte messbare Signaländerung im physischen Übertragungsmedium definiert ist. Da die Übertragung im diesem Standard binär ist, ist ein Symbol als ein Bit definiert. Dieses hat als Folge, dass im diesem Spezialfall die Bitrate und die Baudrate gleich sind.

\paragraph{}
Die Baudrate wird vom Benutzer frei wählbar eingestellt. Dafür muss der Benutzer die Kabellänge betrachten. Weil es sich um eine Spannungsübertragung handelt, muss der Leistungswiederstand und die Kapazität des Kabels beachtet werden. Je länger das Kabel, desto starker nimmt die Spannung ab. Nach Erfahrungswerte von Texas Instruments ist bei einer Baudrate von 9600, eine maximale Kabellänge von 152 Meter möglich. Bei 115200 muss das Kabel kürzer als 2 Meter sein.

\paragraph{}
Der Empfänger muss die Datenübertragung anhalten können, wenn er keine Daten mehr verarbeiten kann. Dieser Handshake wird softwaretechnisch oder über die Hardware mit Steuerleitungen.

\paragraph{}
Bei der Softwarelösung werden am Sender spezielle Steuerzeichen gesendet. Dieses Protokoll ist als "`Xon/Xoff"' bekannt. Es ist nur möglich dieses Protokoll zu benutzen wenn die Steuerzeichen(Xon = 0x11 und Xoff = 0x13) nicht in der Nutzdaten vorkommen.

\paragraph{}
Bei der Hardwarelösung signalisieren Sender und Empfänger sich gegenseitig ihren Status. Solche Protokoll besteht zum Beispiel aus fünf Steuerleitungen(TxD, RxD, GND, RTS und CTS).

\paragraph{}
Damit triviale Fehler vermieden werden, müssen Sender und Empfänger die gleichen Einstellungen haben. Das heißt dass die Baudrate, Stopbits, Parität, Handshake und Kabellänge müssen stimmen.


%#######################################################################################
\subsection{UART}
Universal Asynchronous Receiver Transmitter(UART) ist eine elektronische Schaltung zur Realisierung von digitalen seriellen Schnittstellen(für diese Arbeit der sogenannte COM Port). Der UART ist zum senden und empfangen von Daten über eine Datenleitung vorgesehen. Im industriellen Bereich ist der UART unter die RS 232 Standard sehr verbreitet. Auch in Wincor Nixdorf wird diese Schnittstelle zum steuern der COM Ports benutzt.

%#######################################################################################
\subsection{Paritätsbit}
Wie schon erwähnt, ist die Parität nicht im RS 232 Standard definiert, aber sie ist für diese Arbeit relevant. Das Paritätsbit dient zur Erkennung fehlerhafte Übertragungen. Die Parität kann gerade(even) oder ungerade(odd) sein und wird durch die Anzahl an Einsen in einer Bitfolge bestimmt. Ist eine gerade Parität festgelegt, wird bei einer gerade Anzahl an Einsen eine Null angehängt, bei ungerade Anzahl eine Eins. Genau das Gegenteil geschieht bei  ungerade definierte Parität. Nach unseren Beispiel mit 0x7A wird bei gerade Parität eine Eins ("`0 0101 1110 \textbf{1} 11"') angehängt.

%#######################################################################################
\subsection{Leitungen und Stecker}
\paragraph{}
Am Anfang wurde der 25-polige D-Sub-Stecker verwendet. Viele dieser 25 Leitungen sind reine Drucker und Terminal-Steuerleitungen aus der elektromechanischen Zeiten, somit waren sie für die modernere Peripherie überflüssig. So hat sich der 9-polige D-Sub-Stecker(COM Port) etabliert. Dieser Stecker war nicht ursprünglich für diesen Standard gedacht, sondern wurde von IBM, als Notlösung in einen anderen Standard, um Platz zu sparen entwickelt. Der Stecker ist daher unter EIA/TIA-574 zu finden. Für die EIA-232-Datenübertragung werden selten andere Stecker benutzt und in Wincor Nixdorf ist das auch keine Ausnahme.


\paragraph{}
Der 9-polige D-Sub-Stecker besteht aus folgenden Leitungen:\\
\begin{tabular}{llll}
\\
TxD, TX, TD &: Transmit Data, Leitung für ausgehende Daten \\
RxD, RX, RD &: Recieve Data, Leitung für ankommende Daten \\
RTS &: Request To Send, Sendanforderung \\
CTS &: Clear To Send, Sendeerlaubnis \\
DSR &: Data Set Ready, Einsatzbereitschaft \\
GND &: Ground, Signalmasse \\
DCD, CD, RLSD &: Data Carrier Detect, Erkennung einlaufende Daten \\
DTR &: Data Terminal Ready, Datenendeinrichtung ist bereit \\
RI &: Ring Indicator, Datenverbindungsaufbau \\

\end{tabular}

\paragraph{}
EIA-232 ist eine Spannungsschnittstelle, also werden die logische Null und Eins durch positive / negative Spannungen vertreten. Die Datenleitungen (TxD und RxD) benutzt eine negative Logik. Spannung zwischen -3V und -15V repräsentieren eine logische Eins. Signale zwischen -3V und +3V gelten als nicht definierte Signale. Die logische Null wird als eine Spannung zwischen +3V und +15V interpretiert. 
 
\paragraph{}
Bei den Steuerleitungen, bezogen auf dem Empfänger, wird ein Signal zwischen +3V und +15V als aktiv betrachtet, und inaktiv zwischen -3V und -15V. Beim Sender üblicherweise ±12V.

\paragraph{}
Um Sender und Empfänger zu verbinden, gibt es verschiedene Kabelvarianten, abhängig von wer Sender und wer Empfänger ist. Verbindet man ein Rechner (in der Regel mit einem Stecker) zu einem Modem (mit einer Buchse) ist ein 1:1 Kabel nötig. Sind zwei Rechner mit einander Verbunden, so ist die Rede von einem Nullmodem Kabel, wo die Leitungen gekreuzt sind. Durch ein Loopback-Stecker bzw. Kurzschlussstecker wird die Sendeleitung direkt and die Empfangsleitung der gleichen Schnittstelle umgeleitet. So ein Stecker wird für die Entwicklung und Test von Kommunikationsanwendungen und Hardware(UART) benutzt.


%#######################################################################################
\subsection{RS 232 in Wincor Nixdorf}
Die BEETLE Systeme haben alle?????? ein integrierten UART im Chipsatz. Diese COM Ports werden "`Onboard Ports"' benannt. Je nach System sind zwei bis sechs COM Ports eingebaut. Wenn ein Kunde weitere Schnittstellen benötigt, kann über den PCI Bus die Anzahl an Ports erweitert werden. Diese Erweiterung findet statt durch eine Sunix PCI Karte mit vier oder acht COM Ports.
\\
Intel SOL 
\\
ITE
\\
stromversorgung
ba66
kassenlade

%****************************************************************************************
\newpage
%****************************************************************************************

\section{Microsoft Windows API}

Die Quellen des folgenden Kapitel sind aus "`Programming Windows, Charles Petzold, 1995, 5. Auflage"' und "`Visual C++ 2010, Dirk Louis, 2010"'.

%#######################################################################################
\subsection{Definition}

\paragraph{}
Die Microsoft Windows "`Application Programming Interface"'(Schnittstelle zur Anwendungsprogrammierung) ist ein Programmteil, dass vom Windows Betriebssystem den Benutzern und vor allem Entwicklern angeboten wird, um Programme an das Betriebssystem anbinden zu können. Ein Betriebssystem (Microsoft Windows, Mac OSX, Linux, unter anderem) ist für Entwickler und Programmierer durch die API definiert. Somit kann eine Applikation über die API alle Funktionsaufrufe machen, die ein Betriebssystem anbietet. Nicht nur Funktionen sind in einer API definiert, sondern bestimmte Datenstrukturen und Datentypen durch das Kommando \textit{typedef} wie \textit{LRESULT} oder \textit{CALLBACK}.
\paragraph{}
Mit fast jedes neue Microsoft Betriebssystem wird die Windows API erweitert und abgeändert. Die erste API, bekannt als \textit{Win16}, für die 16-Bit Versionen von Microsoft Windows. Für Windows 1.0 hatte die API etwa 450 Funktionsaufrufe. Bei der Zeit von Windows 98 wurde die API auf 32-Bit und mehrere tausende Funktionsaufrufe. Ab Windows XP "`x64 Edition"' und Windows Server 2003 wurde die API auch auf 64-Bit erweitert.
\paragraph{}
Der hauptsächliche Unterschied zwischen die 16, 32 und 64 Bit Versionen von der API entstand durch die verschiedene Speicher und Prozessor Architekturen. Unter der 16-Bit Architektur war die Registergröße 16 Bit unter die bekannte Prozessoren von Intel 8086 und 8088. In der 32-Bit Architektur, 32 Bit bzw. in der 64-Bit, 62 Bit groß. Die Windows API ist in der Programmiersprache "`C"' geschrieben. Deswegen war unter die 16-Bit Architektur der Datentyp \textit{int} "`nur"' 16 Bit lang(Zahlen von -32.768 bis 32.767) . In der Speicherverwaltung bestanden Speicheradressen aus einen 16-Bit Segment und einen 16-Bit offset Zeiger. Für Programmierer war diese Verwaltung sehr Umständlich, da der Programmierer genaue Unterscheiden musste, zwischen \textit{long} oder \textit{far} und \textit{short} oder \textit{near} Zeiger. 
\paragraph{}
Ab die 32-Bit Architektur entstand die "`Flat Memory Model"', wo der Prozessor direkt die gesamte Speicheradressen ansprechen konnte, ohne Speichersegmentierung oder Pagingschemas. Somit wurde auch der \textit{int} Datentyp auf 32 Bitgröße(Zahlen von -2.147.483.649 bis 2.147.483.647) definiert. Programme geschrieben unter eine 32-Bit Architektur benutzen einfache Zeigerwerte um direkt die Speicheradresse ansprechen zu können. Bei der Umstellung von 16-Bit auf 32-Bit blieben viele Funktionsaufrufe gleich, aber manche brauchten eine Umstellung auf 32-Bit. Wie zum Beispiel das graphische Koordinatensystem für GUI Darstellungen.
\paragraph{}
 Aus Kompatibilitätsgründe sind die API's Rückwärts kompatibel. Die Kompatibilität entsteht durch eine Übersetzungsschicht. Es gibt zwei Wege der Übersetzung. In den ersten Weg, werden 16-Bit Funktionsaufrufe durch eine Übersetzungsschicht in 32-Bit Funktionsaufrufe umgewandelt und dann vom Betriebssystem bearbeitet. Der andere Weg führt genau in der anderen Richtung.Die 32-Bit Funktionsaufrufe durch die Übersetzungsschicht und wandelt diese in 16-Bit Funktionsaufrufe, und werden dann vom Betriebssystem bearbeitet.
\paragraph{}
Die Benutzung der API ist nicht die einzige Möglichkeit Anwendung für die Windowsbetriebssysteme zu programmieren. Aber durch die Benutzung der API ist eine bessere Leistung, mehr Macht und Flexibilität in das Ausnutzen der Betriebssystemfunktionen garantiert. Durch die Verwendung der API versteht man Windows als Betriebssystem besser. Man kann Anwendungen auch in Visual Basic oder Borland Delphi schreiben, wo die objektorientierte Grundlagen von Pascal den Programmierer viel arbeitet erleichtern kann. Aber das Stapeln von Programmierschichten über die API versteckt nur die Komplexität der API, und früher oder später wird man im Programm mit dieser Komplexität konfrontiert.


%----------------------------------------------------------------------------------------------
\subsubsection{API gegenüber .NET Framework}
\paragraph{}
Microsoft hat dieses Framework speziell für die Windows-Plattformen entwickelt. Es ist eine Virtuelle Maschine als Laufzeitumgebung für Microsoft Windows Anwendungen. Dieses Framework gleich in vieles die Java Virtual Machine. Das .NET Framework besteht aus eine Laufzeitumgebung und die .NET Framework-Bibliothek. Aus Sicht des Anwenders hat sich nichts geändert, aber für die Programmierer vieles. Das .NET Framework ist auf C++ und C\# basierend, und im Gegensatz zur API, objektorientiert. Die Framework-Bibliothek besteht aus verschiedenen Klassenbibliotheken wie die Windowa Forms, Windows Presentation Foundations (GUI), Webdienste, unter anderem. Ein großer Vorteil ist die Portierung der Programme, dafür muss das .NET Framework installiert sein. Das ist für dieses Projekt essentiell, denn es soll auf Schreibgeschütze Medien ausführbar sein (Win PE) und aus diesem Grund für meine Lösung nicht betrachtet.




%#######################################################################################
\subsection{Windows.h}

Die Window.h Headerdatei ist die Masterdatei, dass alle andere Headerdateien inkludiert. In diesen Dateien sind die Funktionsaufrufe, Konstanten, Typdefinitionen und Datenstrukturen für das Windowsbetriebssystem definiert. Diese Headerdateien sind die Teil der Dokumentation für den Programmierer. Wer die Headerdateien kennt, weiss auch was man unter windows programmieren kann. Die wichtigsten Headerdateien sind:

\begin{tabular}{llll}
\textbullet & WINBASE.H & Kernenfunktionen\\
\textbullet & WINDEF.H  & Typdefinitionen\\
\textbullet & WINNT.H  & Typdefinitionen mit Unicode Unterstützung\\
\textbullet & WINUSER.H  & Funktionen für die Benutzerschnittstelle\\
\textbullet & WINGDI.H  & Graphische Schnittstelle\\
\end{tabular}

%#######################################################################################
\subsection{WinMain}
\paragraph{}
\textit{C/C++} Programme fangen mit eine \textit{int main()} Funktion an. Da die API auf \textit{C} implementiert ist, fangen Anwendungen mit Windows als Zielsystem mit eine ähnliche Funktion an. Unter Windows ist die \textit{main} Funktion unter "`WINBASE.H"' als:

\begin{tabbing}

int WINAPI \=WinMain(\\
    			\>HINSTANCE hInstance,\\
    			\>HINSTANCE hPrevInstance,\\
    			\>LPSTR lpCmdLine,\\
    			\>int nShowCmd\\
			\>);

\end{tabbing}

\paragraph{}
Als erstes fällt auf der Bezeichner \textit{WINAPI}. Dieser Datentyp ist definiert als \textit{WINAPI \_\_stdcall}. \textit{\_\_stdcall} ist eine Aufrufkonvention um Funktionen aus der Win32 API aufzurufen. Die \textit{WinMain} Funktion bekommt als Parameter zwei \textit{HINSTANCE} Variablen, ein \textit{LPSTR} und ein \textit{int}.

\paragraph{}
\textit{HINSTANCE} ist ein Handle auf eine Instanz. Das ist die Basisadresse von einem Modul im Systemspeicher(eine 32-Bitzahl, dass auf ein Objekt zeigt). Das erste Parameter ist dann eine Instanz auf die aktuelle Anwendung. Das zweiter Parameter wurde nur unter Win16 benutzt und ist unter die Win32 API irrelevant, es wird automatisch auf \textit{NULL} gesetzt. Das dritte Parameter enthält die Befehlszeilenargumente als Zeichenfolge. Aus dieser Zeichenfolge wertet das Programm aus, wie es ausgeführt werden soll. Das vierte und letzte Parameter ist ein Flag und gibt an wie das Anwendungsfenster angezeigt werden soll (Minimiert, Maximiert oder Normalgröße).

%#######################################################################################
\subsection{Graphic User Interface (GUI)}
\paragraph{}
Durch die grenzwertige Hardware(Speicher und Prozessoren) waren alle Betriebssysteme Kommandozeileorientiert. Dies sollte sich aber ändern durch die Recherche von Xerox Palo Alto Research Center(PARC). Mitte der 70 Jahren wurde in Xerox PARC nach graphische Benutzeroberflächen recherchiert. Aus diesen Ergebnisse profitierten Macintosh und Windows, und bauten darauf Ihre Betriebssysteme mit graphischen Benutzeroberflächen(Mac OS und Windows). Heutzutage kann man sich als Benutzer kaum eine Computerwelt ohne Benutzeroberflächen vorstellen. Die Windows API hat seit der Ankündigung(1983) und Veröffentlichung(1985) von Windows als Betriebssystem Funktionsaufrufe in die Headerdateien für die Programmierung von GUI's. Die Benutzung der API für die Programmierung von GUI's ist vielleicht "altmodisch", aber immerhin sehr genau und präzise. Im Gegensatz zu "`GUI Builders"' wird kein unnötiger, und oft für Programmierer, unverständlicher Code geschrieben. Der Überblick und Verständnis der GUI Elemente wird durch die direkte Benutzung der API vereinfacht. Vor allem wird das Verständnis wie eigentlich eine GUI unter Windows und Windows als Betriebssystem funktioniert, durch die Verwendung der API deutlicher.

%#######################################################################################
\subsection{Aufbau einer GUI}
\paragraph{}
Nachdem die \textit{WinMain} Funktion die nötige Parameter bekommt und diese vom Programm ausgewertet werden, muss die GUI als solche gebaut und registriert werden. Eine GUI besteht aus drei Teile.


%----------------------------------------------------------------------------------------------
\subsubsection{Initialisierung und Erzeugung der GUI}
\paragraph{}
Damit der Benutzer ein Programmfenster sehen kann, muss dieses zuerst deklariert und initialisiert werden. Danach wird dieses Fenster an das System bekannt gegeben in dem man es registriert. Um ein Fenster zu deklarieren muss man eine Variable der Struktur \textit{WNDCLASS} erzeugen. Diese Struktur definiert in \textit{WINUSER.H} beinhaltet verschiedene Variablen die die Eigenschaften des jeweiliges Fenster beschreiben.



\begin{tabular}{llll}
& typedef struct\\
& \{\\
& & UINT        & style ;\\
& & WNDPROC     & lpfnWndProc ;\\
& & int         & cbClsExtra ;\\
& & int         & cbWndExtra ;\\
& & HINSTANCE   & hInstance ;\\
& & HICON       & hIcon ;\\
& & HCURSOR     & hCursor ;\\
& & HBRUSH      & hbrBackground ;\\
& & LPCTSTR     & lpszMenuName ;\\
& & LPCTSTR     & lpszClassName ;\\
&\}WNDCLASS,&* PWNDCLASS ;
\end{tabular}
\\


\paragraph{}
Die zwei wichtigsten Variablen dieser Struktur sind der zweite und letzte. Die zweite Variable \textit{WNDPROC lpfnWndProc} beschreibt die Fensterprozedur. Genaueres zu dieser Variable wir demnächst erklärt. Die letzte Variable \textit{LPCSTR lpszClassName}, beschreibt die Klasse des Fensters. Die Variable \textit{HINSTANCE hInstance} muss den Leser bekannt sein. Diese Variable wird auf den Wert gesetzt, welches das Programm über die \textit{WinMain} bekommen hat. Alle andere Variablen der Struktur beschreiben wie das Fenster aussehen soll und sind für das Verständnis weiterhin irrelevant.

\paragraph{}
Nachdem die \textit{WNDCLASS} Struktur deklariert und initialisiert wird, muss diese registriert werden. Durch den Aufruf der Funktion \textit{RegisterClass}, die als Übergabe Parameter ein Zeiger auf eine \textit{WNDCLASS} Struktur hat, wird dem System bekannt gegeben, dass ein Fenster aufgebaut werden soll (mit dem gesetzten Eigenschaften der \textit{WNDCLASS} Struktur). Wenn das Registrieren erfolgreich war, muss das Fenster noch erzeugt werden. Das System kennt das Fenster, aber es ist noch nicht sichtbar.

\paragraph{}
Damit ein Fenster sichtbar wird, muss der Programmierer die \textit{CreateWindow}\footnote{http://msdn.microsoft.com/en-us/library/windows/desktop/ms632679(v=vs.85).aspx; 27.08.2013} Funktion aufrufen. 


\begin{tabular}{llll}
&HWND WINAPI CreateWindow (&\\
& & In\_opt & LPCTSTR lpClassName,\\
& & In\_opt & LPCTSTR lpWindowName,\\
& & In      & DWORD dwStyle,\\
& & In      & int x,\\
& & In      & int y,\\
& & In      & int nWidth,\\
& & In      & int nHeight,\\
& & In\_opt & HWND hWndParent,\\
& & In\_opt & HMENU hMenu,\\
& & In\_opt & HINSTANCE hInstance,\\
& & In\_opt & LPVOID lpParam\\
&);
\end{tabular}


\paragraph{}
Diese Funktion ist sehr wichtig bei der Erzeugung von graphischen Oberflächen, denn man kann alle Arten von Fenstern damit erzeugen. Damit wird gemeint, dass diese Funktion  nicht nur "`Hauptfenster"', sondern auch die einzelnen GUI Elemente erzeugt. Das erste Parameter beschreibt dieses Verhalten. Die \textit{CreateWindow} Funktion erwartet eine null terminierte Zeichenkette. Diese Zeichenkette ist immer eine vordefinierte Systemklasse. Zum Beispiel, um ein Knopf zu erstellen, muss hier als Parameter "`button"' angegeben werden. Wenn der Programmierer ein von ihm erzeugtes Fenster darstellen will, muss er deswegen vorher im System eine Fensterklasse registrieren. Aus diesem Grund muss der Programmierer eine Fensterstruktur \textit{WNDCLASS} registrieren. Um danach ein selbst gebautes Fenster zu erzeugen, muss der Programmieren das registrierte Fensterklassenname(\textit{WNDCLASS lpszClassName}) angeben (anstatt "`button"' oder andere vordefinierte Fensterklassen).

\paragraph{}
Der zweite Parameter beschreibt der dargestellter Name des Fenster. \textit{DWORD dwStyle} ist eine Bitmaske die den Darstellungsart des Fensters beschreibt. Die Darstellungsarten sind als konstante Werte (Window Styles\footnote{http://msdn.microsoft.com/en-us/library/windows/desktop/ms632600(v=vs.85).aspx; 27.08.2013})in die \textit{WINUSER.H} Headerdatei definiert. Um ein "`traditioneles"' Fenster zu erzeugen muss hier \textit{WS\_OVERLAPPEDWINDOW} angegeben werden. Die Nächste vier Parameter Beschreibe die Positionierung im Bildschirm und die Breite und Höhe des Fensters. 

\paragraph{}
\textit{HWND hWndParent} beschreibt ein Handle auf ein anderes Fenster. Im Falle, dass dieses Fenster das Hauptfenster ist, wird hier NULL übergeben, sonst das Handle auf das "`Parent Windows"'. Das \textit{HMENU hMenu} ist für Hauptfenster irrelevant. Es ist aber wichtig für Unterfenster(Popup Fenster oder GUI Elemente wie Knöpfe). \textit{HMENU} ist eine Typdefinition für ein Handle auf ein Fenstermenü oder ein Unterfenster. Somit kann das Hauptfenster eine Kommando eines GUI Elements erkennen und auswerten, mehr dazu unter "`Die Message Loop"'. Das \textit{HINSTANCE hInstance} wurde schon vorher erläutert und das letzte Parameter beschreibt extra Information wenn es nötig ist, üblicherweise wird hier NULL angegeben.

\paragraph{}
Die \textit{CreateWindow} Funktion liefert als Rückgawert ein \textit{HWND}. Dies steht für Handle auf ein Fenster. Somit kann der Programmierer und Programm auf ein gewünschtes Fenster zugreiffen. Um die erwähnte Parameter genauer zu verstehen folgende Beispiele. Hat man ein Hauptfenster, so ruft man die \textit{CreateWindow} Funktion folgendermaßen:

\begin{tabular}{llll}
& HWND hwnd\_Fenster = CreateWindow (\\
\\
& szAwendungsName,					& //Fensterklasse vom Programmierer registriert\\                            
& "Das ist eine Hauptfenster",  	& //Text auf der Titelleiste\\                                
& WS\_OVERLAPPEDWINDOW,              & //Stil des Fensters\\                         
& CW\_USEDEFAULT,                    & //Position in der X Koordinate des Bildschirmes\\     
& CW\_USEDEFAULT,                    & //Position in der Y Koordinate des Bildschirmes\\     
& CW\_USEDEFAULT,                    & //Lange des Fensters\\                                  
& CW\_USEDEFAULT,                    & //Breite des Fensters\\                                 
& NULL,                              & //Kein zugehöriges Hauptfenster\\                           
& NULL,                              & //Keine Identifikationsnummer\\                               
& hInstance,                         & //Programminstanz\\                                 
& NULL                               & //keine extra Information\\  
& );                          
\end{tabular}                        

\paragraph{}
Will der Programmierer ein GUI Element (wie zum Beispiel ein Knopf) im Hauptfenster darstellen, muss die Funktion mit diesen Parametern aufgerufen werden:
\\
\\
\begin{tabular}{llll}
& HWND hwnd\_Knopf = CreateWindow (\\
\\
& "button",					& //Fensterklasse Knopf\\
& "Das ist ein Knopf",		& //Text auf den Knopf\\
& WS\_CHILD | WS\_VISIBLE,	& //Child Fenster und anzeigen\\
& 100,						& //Position in der X Koordinate des Hauptfensters\\
& 100,						& //Position in der Y Koordinate des Hauptfensters\\
& 50,						& //Lange des Knopfes\\
& 35,						& //Breite des Knopfes\\
& hwnd\_Fenster,				& //Zugehöriges Hauptfenster\\
& (HMENU) ID\_KNOPF,			& //Identifikationsnummer, wird vorher deklariert\\
& NULL,						& //keine Instanz\\
& NULL						& //keine extra Information\\
& );
\end{tabular}

\paragraph{}	
					
Nachdem der Programmierer ein Hauptfenster erzeugt hat, muss dieses noch explizit mittels der Funktionen \textit{ShowWindow(hwnd\_Fenster, iCmdShow)} und \textit{UpdateWindow(hwnd\_Fenster)}	angezeigt werden.

%----------------------------------------------------------------------------------------------				
\subsubsection{Die Message Loop}
\paragraph{}
Windows hat eine Nachrichten Schleife (message loop) für jede laufende Anwendung. Wenn der Benutzer ein Event auslöst(Mausklick oder Tastatureingabe) muss das Programm reagieren. Windows übersetzt das Event in eine Nachricht und diese Nachricht wird in die Schleife reingeschrieben. Wenn eine neue Nachrichten empfangen wird, bevor die aktuelle Nachricht fertig bearbeitet wurde, wird die ankommende Nachricht in die "`Message Queue"'(Warteschlange) geschrieben. Jede Nachricht ist durch die \textit{MSG} Struktur beschrieben.

\begin{tabular}{llll}
& typedef & struct tagMSG\\
& \{\\
&  & HWND   & hwnd ;\\
&  & UINT   & message ;\\
&  & WPARAM & wParam ;\\
&  & LPARAM & lParam ;\\
&  & DWORD  & time ;\\
&  & POINT  & pt ;\\
& \}\\
& MSG,&* PMSG;\\
\end{tabular}

\paragraph{}
Jede Nachricht hat als erster Parameter ein Handle auf das zugehörige Fenster. Danach als \textit{unsigned int (UINT)} wird die Nachricht übergeben. Diese Nachrichten sind in \textit{WINUSER.H} deklariert und habe den Präfix \textit{WM} für "`Window Message"'. Zum Beispiel wird ein Mausklick in das Fenster gemacht, schickt Windows eine Nachricht an das Fenster(durch \textit{hwnd} angegeben) mit der Nachricht \textit{WM\_RBUTTONDOWN}.

\paragraph{}
\textit{wParam} und \textit{lParam} sind 32-Bit Nachrichtenparametern, abhängig vor der jeweiligen Nachricht. Wird zum Beispiel auf eine Knopf gedrückt, wird die \textit{WM\_COMMAND} Nachricht verschickt. Damit die Anwendung genau erkennen was für eine Aktion ausgeführt worden ist, wird in \textit{wParam} noch zwei weitere Angaben mitgeschickt. In die oberen 16-Bits wird die Notifikation \textit{BN\_CLICKED} verschickt. Dies deutet an, dass ein Knopf geklickt worden ist. In den unteren 16-Bits von \textit{wParam} wird die Identifikationsnummer(nach den obigen Beispiel: ID\_KNOPF) des Knopfes mitgeschickt. Mit diesen Informationen kann ein Programm genau auf die vom Benutzer ausgelöste Events reagieren. Beider 16-Bit Werte werden mit Hilfe der Makros \textit{HIWORD} \footnote{http://msdn.microsoft.com/en-us/library/windows/desktop/ms632657(v=vs.85).aspx; 27.08.2013} und \textit{LOWORD} \footnote{http://msdn.microsoft.com/en-us/library/windows/desktop/ms632659(v=vs.85).aspx; 27.08.2013}.

\paragraph{}
Der Parameter \textit{time} gibt die Uhrzeit wann die Nachricht verschickt worden ist und der Parameter \textit{pt} ist eine \textit{POINT} Struktur, wo die X und Y Koordinaten des Mausklicks gespeichert sind.

\paragraph{}
Eine Nachrichten Schleife ist standardmäßig so aufgebaut:

\begin{tabular}{llll}
while & (GetMessage (\&msg, NULL, 0, 0))\\
\{\\
     & TranslateMessage (\&msg) ;\\
     & DispatchMessage (\&msg) ;\\
\}\\
\end{tabular}

\paragraph{}
Die \textit{GetMessage} Funktion speichert in der \textit{msg} Struktur die aktuelle Nachricht. Die drei andere Parameter spezifizieren, dass alle Nachrichten(von der jeweilige Anwendung) in die Schleife geschrieben werden. Die Funktion liefert immer ein Wert ungleich Null, außer wenn die Nachricht \textit{WM\_QUIT} lautet, denn damit wird die Schleife verlassen und das Programm beendet.

\paragraph{}
\textit{TranslateMessage} gibt die Nachricht an das Betriebssystem weiter und übersetzt die virtuelle Tasten Nachrichten auf tatsächliche Charakteren. Die \textit{DispachtMessage} Funktion gibt die an Windows weiter. Gemeint ist, dass Windows die richtige Fensterprozedur (\textit{WndProc} wird später erklärt)aufruft. Wenn die Fensterprozedur die Nachricht bearbeitet hat, gibt die Nachricht wieder an Windows. Windows gibt die bearbeitete Nachricht weiter an die jeweilige Anwendung und so kann die Schleife die nächste Nachricht laden und bearbeiten.



%----------------------------------------------------------------------------------------------
\subsubsection{Fensterprozedur: WndProc Funktion}
\paragraph{}
Unter der Initialisierung und Erzeugung der GUI wurde die Fensterprozedur schon einmal erwähnt. In dieser Variable ist der Name der Funktion, die die Nachrichten eines Fensters bearbeitet. Das heißt, wird eine Fensterstruktur als \textit{WNDCLASS wc} deklariert, und der Parameter \textit{WNDPROC lpfnWndProc} folgendermaßen initialisiert \textit{wc.lpfnWndProc = WndProc;} muss die Fensterprozedur für dieses Fenster \textit{WndProc} heißen. Wie die Fensterprozedur heißt ist irrelevant, solange die Namen in der Fensterklasse und die Prozedur übereinstimmen, somit sind Fenster und Prozedur verbunden. Eine Fensterprozedur ist immer so definiert:

\begin{tabular}{ll}
LRESULT CALLBACK & WndProc(\\
& HWND hwnd,\\
& UINT message,\\
& WPARAM wParam,\\
& LPARAM lParam);
\end{tabular}



\paragraph{}
Der Datentyp \textit{CALLBACK} ist schon bekannt, und \textit{LRESULT} ist eine Typdefinition von \textit{long}. Die vier Parameter der Funktion sind die gleichen wie die ersten vier Parameter bei eine \textit{MSG} Struktur. Falls ein Programm mehrere Fenster von der gleichen Fensterklasse hat, spezifiziert das erste Parameter welches Fenster(Handle) die Nachricht schickt. Programme rufen die Fensterprozedur in der Regel nicht auf, sondern Windows. Will ein Programm die Prozedur direkt aufrufen, dann wird die Funktion \textit{SendMessage}(wird später genauer erklärt) benutzt. 

\paragraph{}
Der Sinn für eine von Programmierer geschriebene Fensterprozedur ist, dass ein Programm auf ein Event reagiert soll, wie der Programmierer es will. Programmierer programmieren in der Regel nicht alle Events. Damit eine Nachricht nicht unbearbeitet bleibt, wird immer am Ende der selbstgeschriebene Fensterprozedur die \textit{DefWindowProc} Funktion aufgerufen. Diese Methode bearbeitet alle mögliche Nachrichten und ist die default Fensterprozedur. Wenn der Programmierer diese Funktion nicht aufruft, werden grundlegende Funktionen einer GUI nicht funktionieren.

\paragraph{}
Die erste Nachricht die eine Fensterprozedur bekommt ist \textit{WM\_CREATE} Nachricht. Hier baut der Programmierer alle GUI Elemente auf, mithilfe der \textit{CreateWindow} Funktion(Knopf Beispiel). Eine zweite sehr wichtige Nachricht ist \textit{WM\_DESTROY}. Die Nachricht wird verschickt wenn der Benutzer ein Fenster zu machen will. Der Programmierer ruft die \textit{PostQuitMessage(0)} Funktion auf und automatisch wird eine \textit{WM\_QUIT} Nachricht verschickt. Somit wird das Fenster geschlossen, die Message Loop verlassen und das Programm / Fenster richtig beendet.

\paragraph{}
Es gibt noch weitere Nachrichten, die der Programmierer "`manuell"' verschicken kann. Mit Hilfe der erwähnte \textit{SendMessage} \footnote{http://msdn.microsoft.com/en-us/library/windows/desktop/ms644950(v=vs.85).aspx; 28.08.2013} Funktion. Die Funktion hat die gleichen Parameter wie eine Fensterprozedur. Durch das Handle wird angegeben an welches Fenster die Nachricht verschickt werden soll. Durch das zweite Parameter wird angegeben, welche Nachricht verschickt wird, und die letzten zwei sind extra Informationen der Nachricht(wenn nötig). Will der Programmierer im Ablauf des Programms zum Beispiel der Darstellungstext von unseren Knopf ändern, wird die \textit{SendMessage} Funktion so aufgerufen:

\begin{center}
SendMessage(hwnd\_Knopf, WM\_SETTEXT, 0, (lParam)"NeuerText");
\end{center}

%----------------------------------------------------------------------------------------------
\subsection{Die RS 232 Schnittstelle und die Windows API}
\paragraph{}
Über die Windows API hat man direkt Zugriff auf die RS 232 Schnittstelle. Zum verwalten der Schnittstelle und die Eigenschaften zu setzen gibt es verschiedene Datenstrukturen die man aufrufen und ändern muss, je nach Bedarf.


%----------------------------------------------------------------------------------------------
\subsubsection{Öffnen und Schließen eines Ports}
\paragraph{}
Um Zugriff auf die Datenstrukturen zu haben, muss man zuerst eine RS 232 Schnittstelle (COM Port) öffnen. Durch die Funktion CreateFile\footnote{http://msdn.microsoft.com/en-us/library/windows/desktop/aa363858(v=vs.85).aspx; 25.08.2013} bekommt man ein Handle auf den angegeben Port. Ein Handle ist eine Referenzwert zu einer vom Betriebssystem verwalteten Systemressource, im diesem Fall eine im System vorhandene RS 232 Schnittstelle. Mit \textit{CreateFile} kann man auch Zugriff auf Dateien, Datenstreams und andere Kommunikationsressourcen bekommen. Das Handle muss gespeichert werden, denn damit wird der jeweiliger Port identifiziert und angesprochen für weitere Operationen. Durch die \textit{CreateFile} Funktion wird die Datei, oder im diesem Fall die Input / Output Schnittstelle für diese Anwendung reserviert. Das heißt, für das Betriebssystem und andere Anwendungen steht diese Schnittstelle nicht mehr zur Verfügung.

\paragraph{}
Um den richtigen Zugriff auf einen Port zu haben, muss auch die richtige Flags bei dem Aufruf der \textit{CreateFile} Funktion angegeben werden. Als Flags sind die folgende Parameter anzugeben:
\begin{itemize}
\item Schreib und Leserechte
\item Non-Sharing Modus
\item Öffnen vor nur existierende Schnittstellen
\item Asynchron Modus
\end{itemize}


\paragraph{}
Um ein Programm "`sauber"' zu beenden müssen offene Handles geschlossen werden. Durch die Funktion \textit{CloseHandle}\footnote{http://msdn.microsoft.com/en-us/library/windows/desktop/ms724211(v=vs.85).aspx; 25.08.2013} mit Angabe eines gültiges Handles wird dieses geschlossen, und steht für das Betriebssystem und andere Anwendungen wieder zur Verfügung.


%----------------------------------------------------------------------------------------------
\subsubsection{Konfiguration eines Ports}
\paragraph{}
Es gibt drei wichtige Strukturen, die für die Konfiguration einer COM Schnittstelle relevant sind. Mittels dieser Strukturen werden die Eigenschaften, einstellbare Parameter und Wartezeiten einer Schnittstelle eingestellt.

\paragraph{}
Die \textit{DCB}\footnote{http://msdn.microsoft.com/en-us/library/windows/desktop/aa363214(v=vs.85).aspx; 28.08.2013} Struktur definiert die Ansteuerungseigenschaften für die Schnittstelle. Um die Struktur für eine angegebene Schnittstelle zu laden, wird die Funktion \textit{GetCommState} aufgerufen. Diese Struktur besteht aus 28 verschiedene Variablen die ich nicht einzeln benennen werde. Diese Variablen beschreiben wie die Schnittstelle konfiguriert ist. Man kann die Baudrate, Parität, Stopbits, Datenbits, Flusssteuerung und Fehlerbenachrichtigung einstellen.

\paragraph{}
Um die Schnittstelle richtig einzustellen und keine falsche Eingaben in die \textit{DCB} Struktur zu schreiben, ist es sinnvoll vorher die \textit{COMMPROP} \footnote{http://msdn.microsoft.com/en-us/library/windows/desktop/aa363189(v=vs.85).aspx; 28.08.2013} Struktur zu auswerten. Durch die Funktion \textit{GetCommProperties} wird die Struktur für die angegebene Schnittstelle geladen. Diese Struktur besteht aus 18 Variablen und beschreibt die mögliche Einstellung für die Schnittstelle. Die Einstellungen werden aus dem Treiber der jeweiliger Schnittstelle(Onboard Ports, Sunix, Intel SOL oder ITE) gelesen. Die für diese Arbeit relevanter Parameter ist die maximale einstellbare Baudrate.
%wSettableStopParity
%dwSettableParams


\paragraph{}
Während der Übertragung von Daten über eine Serielleschnittstelle sind maximale Wartezeiten fällig. Dieses Werte entstehen durch die Übertragungslänge und die eingestellte Baudrate. Auch die Wartezeit zwischen zwei ankommende Bytes ist wichtig um das Ende der Übertragung zu bestimmen. Diese Werte sollten dynamisch berechnet werden und danach die Schnittstelle einstelle. Dafür ist die \textit{COMMTIMEOUTS} \footnote{http://msdn.microsoft.com/en-us/library/windows/desktop/aa363190(v=vs.85).aspx; 28.08.2013} Struktur zuständig. Die Struktur besteht aus fünf Variablen die die Wartezeiten in Millisekunden angeben. Die erste Variable beschreibt die Zeitüberschreitung zwischen zwei ankommende Bytes, wird dieser Wert überschritten, so wird die Leseoperation beendet.

\paragraph{}
Der zweite und vierte Parameter(jeweils für Lesen und Schreiben) beschreiben die Zeit, die für die Übertragung aller Bytes nötig ist(für die aktuelle Schreibe- oder Leseoperation). Diese Parametern sind von der Baudrate und die Bitlänge eines Charakters. Damit ist gemeint, wie unter 3.1.2 erläutert, ein Charakter kann aus 8 Bits plus Startbit, Stopbit und Parität bestehen. Also werden nicht genau 8 Bits(1 Byte) per Charakter, sondern oft mehr (11 Bits zum Beispiel) übertragen. Die Wartezeit wird durch die folgende Formel berechnet.

\begin{center}
$ Wartezeit = \frac{Anzahl der Bits}{Baudrate} \times 1.1$
\end{center}

\paragraph{}
In der Formel wird mal 1.1 multipliziert um eine 10\% Kulanz zu haben. Der dritte und fünfte Parameter sind eine extra Wartezeit, für jeweils Lesen und Schreiben, die zu der gesamte berechnete Wartezeit pro Lese-/Schreibvorgang addiert wird.

%----------------------------------------------------------------------------------------------
\subsubsection{Lesen und Schreiben}
\paragraph{}


%----------------------------------------------------------------------------------------------
\subsubsection{Events and Interrupts}
\paragraph{}