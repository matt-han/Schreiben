\chapter{Lösungsansätze}\label{chp:loesungsansaetze}

\section{Fehlererkennung}
\paragraph{}
Das Ziel des COM-Port-Test-Tools ist Fehler in der Systemhardware beziehungsweise in der Kommunikation zwischen den Schnittstellen zu erkennen. Damit dieses Ziel erreicht wird, muss die Ermittlung eines Fehlers äußerst genau geschehen. So muss jeder Funktionsaufruf und Kommunikationsvorgang immer abgefragt werden. Bei jeder Abfrage müssen die Fehler ausgewertet und gemeldet werden. Nur so erfüllt das Testprogramm seinen Zweck. Die Herausforderung wird darin bestehen, die Fehler genau zu definieren und sie so zu melden, dass der Tester die Ursache sofort erkennt.

\section{Master Slave Modus zwischen zwei Systeme}
\paragraph{}
Die Synchronisierung zwischen zwei verschiedenen BEETLE Systeme wird eine große Herausforderung darstellen. Dafür wird ein kleines Protokoll oder Handshake definiert. In diesem Vorgang muss der Master wissen, dass der Slave fertig eingestellt ist und bereit für ein Datenverkehr ist. Dabei müssen beide Schnittstellen die richtige Einstellungsparameter (Baudrate, Paritätbits, Stopbits, Datenbits, etc.) besitzen und konfigurieren.

\paragraph{}
Um das Protokoll oder Handshake zu definieren gibt es verschiedene Möglichkeiten. Darunter müssen als erstes die Timeouts beachtete werden. Der Master darf keine Information oder Übertragungstexte senden, bevor der Slave nicht in der Lage ist, Daten zu empfangen. Wäre der Slave nicht bereit sein, wurde der Master ein Lese-Timeout melden, weil er Daten verschickt hat, aber der Empfänger keine Daten zurück versendet . Im Gegensatz, darf der Slave nicht Daten erwarten, so lange der Master nicht in der Lage ist, Daten zu verschicken.

\paragraph{}
Als Grundidee um dieses Problem zu lösen, werde ich Synchronisierungszeiten und Vorgänge einbauen, in dem der Master für eine definierte Zeit auf den Slave wartet, und gegenseitig auch. Wenn diese Zeit abläuft, wird den Benutzer gemeldet, dass es Probleme mit der Synchronisierung beider Systeme gab, und das kein Test stattfinden wird. Ein großer Nachteil dieser Lösung ist, dass durch das Abfragen auf Bereitschaft ein Pollingverfahren\footnote{Das zyklische Abfragen eines Status} entsteht. 

\paragraph{}
Im besten Fall, wo keine Fehler bei der Kommunikation auftreten, wird es nicht so nötig sein, sich ständig zu Synchronisieren. Im Fehlerfall, muss nach jedem Test eine Synchronisierung stattfinden. Empfängt der Slave verfälschte Informationen und meldet ein Fehler, wurde sich sofort auf den nächsten Test vorbereiten. Das wurde den gesamten Testvorgang verfälschen. Es werden weitere ähnliche solche Fälle auftreten auf denen sinngemäß reagiert werden muss.

\paragraph{}
Um das Pollingverfahren zu vermeiden, kann die Synchronisierung auf Basis von Events \footnote{http://msdn.microsoft.com/en-us/library/aa450667.aspx; 30.08.2013} geschehen. Die Schnittstelle erzeugt Interrupts bei der Ankunft von einem Byte. So kann der Slave reagieren, erst wenn der Master was tatsächlich verschickt hat. Um die Interrupts abzufragen, muss ich Kommunikation Events von Windows abfragen. Wenn das System ein Interrupt empfängt, wird dieses im Programm als ein Event weitergeleitet.

\paragraph{}
Im ersten Blick, wird das 100\% Umgehen von einem Pollingverfahren schwer sein. Diese wird sich durch Testen während der Entwicklung des "`WN Serial COM Port Test"' beweisen. Je nach Testergebnisse werde ich die entsprechende Lösung anwenden.


\section{C++ und die GUI}\label{C++GUILoesung}
\paragraph{}
Die graphischen Oberflächen mit Anwendung von der Windows API besteht aus "`C"' Code, und muss eine statische Fensterprozedur besitzen. Das heißt, es können beliebig viele Benutzeroberflächen kreiert werden, aber es gibt nur eine Prozedur die die Nachrichten bearbeitet. Durch die Objektorientierung unter "`C++"' ersteht ein Konflikt wegen der statische Fensterprozedur. Um eine statische Methode zu definieren, müssen auch statische Variablen erzeugt werden. So werden diese Variablen nur einmal erzegut, unabhängig davon, wie viele Fenster erstellt werden. Wäre die Methode und die Variablen nicht statisch und mehrere Fenster werden erstellt, wurden die versendetete Nachrichten durcheinander kommen.

\paragraph{}
Um dieses Problem zu umgehen wird mit Hilfe von einem \textit{"`Template Class"'} die Oberfläche definiert. Eine Klasse wird definiert, in der die allgemeine Eigenschaften eines Fensters gesetzt werden und die Nachrichten von jedem Fenster richtig umgeleitet werden. Dieses geschieht indem die benötigte statische Fensterprozedur in dem Template definiert wird. Die aller ersten Nachricht die ein Programm bekommt um eine Oberfläche zu erzeugen ist die "`WM\_NCREATE"'. Die Fensterprozedur fragt nach dieser Nachricht ab und wenn die Nachricht ankommt, wird durch Zeiger die Fensterhandles richtig gesetzt und weitergeleitet an die richtige Prozedur. Da diese Fensterprozedur statisch ist, egal wie viele Oberflächen kreiert werden, wird es nur einmal diese Fensterprozedur geben.

\paragraph{}
Die Fensterklasse erbt somit von das \textit{Template Class} und kann eine eigene Fensterprozedur definieren. Der definierten Fensterprozedur in der Fensterklasse werden durch das Template die Nachrichten weitergeleitet. Dadurch werde ich auch in der Lage sein, meine eigene Fenster so zu gestalten wie die Voraussetzungen es definieren. Und falls es nötig ist, mehrere Fenster erzeugen.