%%
%% Beuth Hochschule für Technik --  Abschlussarbeit
%%
%% Anhang
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\lstset{language=C++,
				backgroundcolor=\color{white},
				%frame=single,
				tabsize=2,
				numbers=left,
				numbersep=5pt,
				%numberstyle=\color{light-gray},
				basicstyle=\ttfamily\color{black}\small,
				keywordstyle=\color{HKS51}\bfseries,
				commentstyle=\color{HKS13}\slshape,,
				identifierstyle=\color{black}
		}
		
		
\chapter{Anhang}

\section{Template Class}\label{TemplateClass}
\begin{lstlisting}	
// Quelle:
// http://msdn.microsoft.com/en-us/library/windows/desktop/

template <class DERIVED_TYPE> 
class BaseWindow
{
public:
	//Windows default STATIC message handler
	static LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg,
                                       WPARAM wParam, LPARAM lParam)
	{
		DERIVED_TYPE *pThis = NULL;

		if (uMsg == WM_NCCREATE)
		{
			//extract pointer
			CREATESTRUCT* pCreate = (CREATESTRUCT*)lParam;
			pThis = (DERIVED_TYPE*)pCreate->lpCreateParams;
			SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)pThis);

			pThis->m_hwnd = hwnd;
		}
		else
			pThis = (DERIVED_TYPE*)GetWindowLongPtr(hwnd, GWLP_USERDATA);

		if (pThis)
			return pThis->HandleMessage(uMsg, wParam, lParam);
		else
			return DefWindowProc(hwnd, uMsg, wParam, lParam);
	}//WindowProc

    
	BaseWindow() : m_hwnd(NULL) { }

	BOOL Create(LPCSTR lpWindowName,
				DWORD dwStyle,
				DWORD dwExStyle = 0,
				int x = WINDOW_X,
				int y = WINDOW_Y,
				int nWidth = WIN_WIDTH,
				int nHeight = WIN_HEIGHT,
				HWND hWndParent = 0,
				HMENU hMenu = 0)
    {
		//Window properties
		WNDCLASS wc = {0};
		
		//wc.lpszClassName = L"Serial Port Tester";
		wc.hbrBackground = GetSysColorBrush(COLOR_3DFACE);
		wc.hCursor       = LoadCursor(0, IDC_ARROW);
		wc.hIcon		 = LoadIcon(NULL, IDI_APPLICATION);
		wc.lpfnWndProc   = DERIVED_TYPE::WindowProc;
		wc.hInstance     = GetModuleHandle(NULL);
		wc.lpszClassName =  ClassName();

		RegisterClass(&wc);

		//main window creation and handle
		m_hwnd = CreateWindowEx(
			dwExStyle, ClassName(), lpWindowName, dwStyle, x, y,
			nWidth, nHeight, hWndParent, hMenu, GetModuleHandle(NULL), this);

        return (m_hwnd ? TRUE : FALSE);
    }//create

	HWND window() const { return m_hwnd;}

protected:

    virtual LPCSTR  ClassName() const = 0;
    virtual LRESULT HandleMessage(UINT uMsg,
                    WPARAM wParam, LPARAM lParam) = 0;

    HWND m_hwnd;
};
\end{lstlisting}	


%****************************************************************************************
\newpage
%****************************************************************************************
\section{HandleMessage}\label{HandleMessageCode}

		
\begin{lstlisting}	
LRESULT Window::HandleMessage(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {

    case WM_CREATE:
        {
            //Create all GUI Elements
            
            //example: Start button
            _hwnd_Start = CreateWindowA("button", "Start",
				WS_CHILD | WS_VISIBLE,
				POS_X+20, POS_Y2 + 290, 70, 30, m_hwnd, (HMENU)ID_BT_START,
				NULL, NULL);
        }
        break;
        
    case WM_COMMAND:
        {
            //React to GUI Elements actions
            
            //example: Start button
            case ID_BT_START:

				//hide the elements while testing
				viewAllElements(FALSE);

				//start a new thread
				_t1 = thread(&Window::sendTestSettings, this);
				
				//detach the thread so it can test and
				//main thread waits for it to finish
				//or waits for the user to press stop
				_t1.detach();
        }
        break;
        
    case WM_DESTROY:
        PostQuitMessage(0);
        break;

	//call the default window procedure for the other messages
    default:
        return DefWindowProc(m_hwnd, uMsg, wParam, lParam);
    }
    return TRUE;
}

\end{lstlisting}


%****************************************************************************************
\newpage
%****************************************************************************************
\section{Readdata}\label{ReadDataCode}

\begin{lstlisting}
bool PortCommunications::readData(char * lpBuf, DWORD dwSize)
{
	int iCounter = 0;
	int iErr;
	DWORD dwRead;
	DWORD dwRes;
	char ourBuf[100] = {0};
	int ourCount = dwSize;
	char *ourPtr = lpBuf;

	BOOL fWaitingOnRead = FALSE;
	OVERLAPPED osReader = {0};

	// Create the overlapped event. Must be closed before exiting
	// to avoid a handle leak.
	osReader.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

	if (osReader.hEvent == NULL)
	{
		// Error creating overlapped event; abort.
		clog<<"error creating overlapped event, abort"<<endl;
		CloseHandle(osReader.hEvent);
		return FALSE;
	}

	while(true)
	{
		//if not waiting on read operation, then read
		if (!fWaitingOnRead)
		{
			// Issue read operation.
			if (!ReadFile(hCom, ourBuf, dwSize, NULL, &osReader))
			{
				//if not true
				iErr = GetLastError();
				if (iErr != ERROR_IO_PENDING)     // read not delayed?
				{	// Error in communications; report it.
					clog << "Error reading port. System Error: " << iErr << endl;
					return FALSE;
				}
				else
				{
					clog << "\noperation not completed yet. buffer ->"
					     << ourBuf << endl;
					fWaitingOnRead = TRUE;
				}
			}
			else
			{    
				// read completed immediately
				clog << "read completed immediately" << endl;
				CloseHandle(osReader.hEvent);
				return TRUE;
			}
		}	

	
		if (osReader.hEvent == NULL)
		{
			clog << "Unexpected NULL object " << endl;
			return FALSE;
		}

		dwRes = WaitForSingleObject(osReader.hEvent, WAIT_FOR_READ_OBJ);
		
		switch(dwRes)
		{
			// Read completed. The state of the specified object is signaled	
			case WAIT_OBJECT_0:  
				if (!GetOverlappedResult(hCom, &osReader, &dwRead, FALSE))
				{
					// Error in communications; report it.
					iErr = GetLastError();
					clog << "Error reading port. System Error: " << iErr << endl;
					CloseHandle(osReader.hEvent);
					return FALSE;
				}

				clog << "GetOverlappedResult was ok" << endl;
				
				if(dwRead == 0)
				{
					clog << "No data available to be read. Buffer empty" << endl;
					CloseHandle(osReader.hEvent);
					return FALSE;
				}

				//reset for next read, this was successful
				iCounter = 0;
				
				memcpy(ourPtr, ourBuf, dwRead);
				ourPtr   += dwRead;
				ourCount -= dwRead;
					
				if(ourCount <= 0) 
				{
					clog << "read operation completed" << endl;
					CloseHandle(osReader.hEvent);
					return TRUE;
				}

				//  Reset flag so that another read operation can be issued.
				fWaitingOnRead = FALSE;
				break;

			case WAIT_TIMEOUT:
				//the time out interval elapsed,
				//and the objects state is nonsignaled

				// Operation isn't complete yet. fWaitingOnRead flag isn't
				// changed since I'll loop back around, and I don't want
				// to issue another read until the first one finishes.
				iCounter++;
				if(iCounter == 5)
				{
					clog << "to many object timeouts. ABORT" << endl;
					return FALSE;
				}
				clog << "operation isnt complete yet, carry on..."<<endl;

				break;                       

			default:
				// Error in the WaitForSingleObject; abort.
				// This indicates a problem with the OVERLAPPED structure's
				// event handle.
				clog << "Error while reading in the WaitForSingleObject,\n"
					<< "problem with the overlapped stucture handle" << endl;
				iErr = GetLastError();
				clog << "Unexpected Error WaitForSingleObject. System Error: "
				     << iErr << endl;
				CloseHandle(osReader.hEvent);
				return FALSE;
		}//switch

	}//while
}
\end{lstlisting}



%****************************************************************************************
\newpage
%****************************************************************************************
\section{Writedata}\label{WriteDataCode}

\begin{lstlisting}

bool PortCommunications::writeData(const char * lpBuf, DWORD dwSize)
{
	int iCounter = 0;
	int iErr;
	OVERLAPPED osWrite = {0};
	DWORD dwWritten;
	DWORD dwRes;
	BOOL  fRes = FALSE;

	// Create this write operation's OVERLAPPED structure hEvent.
	osWrite.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
	if (osWrite.hEvent == NULL)
		// Error creating overlapped event handle.
		return FALSE;

	do
	{
		clog << "...Write attempt number: " << iCounter + 1 << endl;
	   // Issue write
		if (!WriteFile(hCom, lpBuf, dwSize, &dwWritten, &osWrite))
		{
			iErr = GetLastError();
			if (iErr != ERROR_IO_PENDING)
			{ 
				// WriteFile failed, but it isn't delayed. Report error.
				fRes = FALSE;
				iCounter++;
				clog << "Error writing to port. System Error: "
				     << iErr << endl;
			}
			else
			{
				// Write is pending.
				dwRes = WaitForSingleObject(osWrite.hEvent, INFINITE);
				switch(dwRes)
				{
					// Overlapped event has been signaled. 
					case WAIT_OBJECT_0:
						if(!GetOverlappedResult(hCom, &osWrite, &dwWritten, FALSE))
						{
							iErr = GetLastError();
							fRes = FALSE;
							iCounter++;
							clog << "Error writing to port. System Error: "
							     << iErr << endl;
						}
						else
						{
						
							if (dwWritten != dwSize)
							{
								// The write operation timed out.
								clog << "The write operation timed out" << endl;
								fRes = FALSE;
								iCounter++;
							}
							else
							{
								//Write operation completed successfully
								fRes = TRUE;
							}
						}
						break;
            
					default:
						// An error has occurred in WaitForSingleObject.
						iErr = GetLastError();
						clog <<"Write error in WaitForSingleObject.\nThis usually "
						     <<"indicates a problem with the overlapped "
						     << "event handle." << endl;
						clog << "Error writing to port. System Error: "
						     << iErr << endl;
						fRes = FALSE;
						iCounter++;
						break;
				}//switch

			}//else to error pending

		}//writefile
		else
		{
			// WriteFile completed immediately.
			if (dwWritten != dwSize) {
				// The write operation timed out.
				clog << "The write operation timed out" << endl;
				fRes = FALSE;
				iCounter++;
			}
			else
				fRes = TRUE;
		}

		if(fRes == TRUE)
		{
			CloseHandle(osWrite.hEvent);
			return fRes;
		}

	}while(iCounter < 5);

	CloseHandle(osWrite.hEvent);

	return fRes;
}

\end{lstlisting}

%****************************************************************************************
\newpage
%****************************************************************************************
\section{Logdatei}\label{LogDatei}
hier kommt die logdatei für ein Kurzchlussstecker


%****************************************************************************************
\newpage
%****************************************************************************************
\section{Testdatei}\label{TestDatei}
hier kommen die testdateien\\
fixed master slave\\
wobble shorted\\
automatic double


%****************************************************************************************
\newpage
%****************************************************************************************
\section{Ablaufdiagramm eines Master - Slave Test}\label{MasterSlaveDiagramm}

\begin{figure}[htbp]
	%\centering 
	\includegraphics[width=15cm]{MasterSlave}  
\end{figure}